\title{Type III (Mixminion) MIX Protocol Specifications}

\section{Message Format}

\subsection{Overview}

Type III (Mixminion) MIX messages are composed of a header section and a
payload.  For technical reasons, each message has a main header and a
sectondary header, both of which have identical structure.  Each
header is further composed of up to 16 subheaders, which are
addressed and encrypted to the intermediate nodes (MIXes).  We
begin by explaining how the full message is structured but starting
with the smallest building block.

\subsection{Definitions and cryptographic primitives}

- if B is a byte array, B[i:j] (j bytes) is sub array starting at 
  byte i with length j.
- R(n) (n bytes) Generates n random bytes by any secure method.
- Z(n) (n bytes) Generates n zero bytes
- Len(M) (2 bytes) is the length of message M (* bytes)
- x|y (Len(x)+Len(y) bytes) denotes x concatenated with y.

- PAD(M,L) (L bytes) pads the message M (Len(M) <= L) to length L
  using zeroes.
- H(M) (20 bytes) is the SHA-1 hash of M (* bytes)
- PK_Encrypt(K,M) (128 bytes): the RSA-encryption of a header M 
  using the public key K.  M is padded using RSA-OAEP, and encoded
  with PCKS1.
- PK_Decrypt(K,M) (up to 86 bytes) Gives the decryption of the
  message M (128 bytes) under the private key corresponding to K.
- Encrypt(K,M) (Len(M) bytes) Rijndael encryption (in Counter mode,
  with 128-bit blocksize) of message M using key K.  (All Rijndael
  operations use 128-bit blocks.)
- Decrypt(K,M,i,j) (j-i bytes) Rijndael counter mode decryption 
  using the key material byte i to j.
- PRNG(K, n) (n bytes) Uses Rijndael in counter mode to produce N
  bytes of pseudo-random numbers.
  PRNG(K, n) = Encrypt(K, Z(n))
- SPRP_ENCRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Uses a super-pseudorandom
  permutation to encrypt M with keys K1-K4.  Specifically, we use LIONESS,
  as described in XXXXCITE, with PRNG(K,n) as our stream generator,
  and the keyed-SHA1 construction specified in the LIONESS paper.

  K1 and K3 are 160 bits long; K2 and K4 are 128 bits long.

  For convenience, we write SPRP_ENC(K,P,M) to denote:
       LIONESS_ENCRYPT(HASH(K|P|" (FIRST SUBKEY)"),
                       HASH(K|P|" (SECOND SUBKEY)")[0:16],
 	               HASH(K|P|" (THIRD SUBKEY)"),
 	               HASH(K|P|" (FOURTH SUBKEY)")[0:16], P)
- SPRP_DECRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Inverts SPRP_ENCRYPT.

  We also define SPRP_DEC(K,P,M) as the inverse of SPRP_ENC.
    
RSA encryption and decryption is used with OAEP padding, using the 
mask function MGF1 and hash function SHA1.  The security
parameter P is set to be the hash of the following 84-character ASCII
string (a quotation from Thomas Paine): 

     "He who would make his own liberty secure, must guard even his
      enemy from oppression." 

All fields are packed in Internet (MSB first) order.

[XXXX I've backed off from using OAEP+: As far as I can tell from the
      literature, the weaknesses in OAEP's security proofs only appear
      when you're using something other than RSA.  With RSA, I believe
      the claim is still that OAEP is secure. -NM]
[XXXX I agree that for most practical purposes OAEP is secure. Using
      the standard construction will allow implementors to use ready
      made libreries. -GD]

\subsection{The subheader structure and address extensions}

A subheader contains all the information that a MIX needs to know
in order to check the integrity of a message and route it through the
Internet. The subheader contains the following fields: 

Subheader fields:

Version Major:   1 byte
Version Minor:   1 byte
Shared Secret:   16 bytes
Digest:          20 bytes
Routing Size:    2 bytes
Routing Type:    2 bytes  [total 43 bytes]
Routing info:    [Routintg Size] bytes

* The Version is present to manage concurrent versions of the
protocol. If a packet is received with a version that is not supported
it should be discarded. Nodes must advertise what versions of the
protocol they support in their status blocks; see below.
(Because having multiple versions makes messages more linkable, it is
important to keep too many from existing at a time.)
* The Shared Secret is the base secret that is used to generate all
other keys for the operations of the node on the packet. It must be
kept secret and discarded as soon as the packet has been processed. 
* The Digest contains an integrity check of the remainder of the
current header (128*15 bytes in total).  It is calculated on the
remailing subheaders and the junk that will be present at then end 
of headers when the node receives the message. 
   [XXXX All the flags were redundant. 
    I removed END because it's redundant with respect to routing type.
    I removed EXTADDR because it's redundant with resped to routing
      size.
    I removed RTRN because it's redundant with respect to routing
       type.
    I removed SWAP because it makes address type redundant.   -NM]
    [XXXX Cool! You are right they were, as long as we make clear that
    routing types make the message being treated in different ways -GD] 	

* The Routing Type of a message defines how the MIX should deliver or
  relay it.  Most routing methods require addition addressing information.
  The Routing Size field indicates the total size of the routing
  information.   If the information is too long to fit in a single
  subheader, it may spill into subsequent subheaders.

  If a MIX receives a routing type it does not recognize, it must
  discard the message. 

  The subheader is are encrypted using RSA after having been padded
  using OAEP+, using a 1024 bit key.  This results in an encrypted block
  of 128 bytes.  If the routing info is longer than 86-42=44 bytes, then
  additional subheader have to be added.
  [XXXX Should the above really be OAEP+? or simply OAEP? -GD]

  When an additional block is added to fit the routing info, it must be be a
  multiple of 128 bytes and should have the following structure:
 
  Routing Extension:

    Magic number:     4 bytes
    Address Data:     Variable
    Padding:          Variable

  [XXXX I removed the number of blocks; it's redundant with respect to
  routing size. -NM]

  [XXXX What purpose does the magic number serve? -NM]
  [XXXX It was originally there to make sure that the decryption was
  correct. It is not releven any more because:
	- we do not use a AONT for the additional block
	  (could modify bits inside without modufying first 4 bytes)
	- the integrity of the additional block is protected by the
  	  message digest in the header (this should be made clear!).
	-GD]

* The magic number is set to be four zero bytes.
* Padding of zeroes is used to make the size of the Address Extension a
multiple of 128 bytes.  

The Address Extension corresponding to a particular subheader is
encrypted using the Encrypt function with key=Hash(Shared Secret,
``ROUTING EXTENSION SECRET KEY'') and appended to the RSA encrypted
subheader.

We will formally refer to the subheader structure as:
SHS(V, SK, D, F, A)
And to the RSA-OAEP encrypted subheader structure as:
ESHS(PK, SK, D, F, A)

\subsection{Routing information}

There are 5 predefined routing types:

0x0000-0x00FF: PROTOCOL SUPPORT

0x0000 DROP    (0 bytes of routing information)
0x0001 FWD/IP4 (IP: 4 bytes, PORT: 2 bytes, KEYID: 20 bytes): 26 bytes
0x0002 SWAP-FWD/IPV4 (same info as FWD/IP4)

0x0100-0x0FFF: PREDEFINED DELIVERY TYPES.

0x0100 SMTP   (EMAIL ADDRESS: variable, TAG: variable) Variable bytes
0x0101 LOCAL  (USER: variable, TAG: variable) Variable bytes

0x1000-0xEFFF: UNALLOCATED

0xF000-0xFFFF: FOR EXPERIMENTAL USE

A DROP routing type indicates a dummy message, to be discarded.

A FWD/IP4 routing type indicates that the message has to be
retransmitted using the TLS/Mixmaster transport protocol. The IP field
of represents the IPv4 address.  The KEYID field represents the hash of
the next node's tranport public key.

[XXXX Are the TLS keys different from the keys used to encrypt the
      headers?  I claim they should be. -NM]
[XXXX YES! They have to be different since they are discarded after
      the key exchange. The signature/verifucation key pair can be
      used for both purposes (signing ethemeral keys, and signing the
      mix encryption keys).

A SWAP routing type tells the node to exchange headers as described below.

The EMAIL field in the SMTP type of address should be a valid email
address [RFC2821].  It must be NUL-terminated.  The TAG field is
appended to the message in an X-Remailer-Tag header.

The LOCAL routing type is used for messages to be delivered to a local
user.  The USER field must be NUL-terminated; the TAG field is
free-form.

(Tag fields can be used to  implement stateless reply blocks by
reminding recipients of the master secrets they used to generate the
reply block.)

[XXXX Where has the RTRN type gone? I guess you can do the same job
with the LOCAL field but I would prefer to have it specified as a
separate type in the standard. 

0x0101 RTRN  (HOPS: 1 byte , KEY: 20 bytes) : 21 bytes

-GD]

\subsection{The header structure}

Each type III message has two identical headers that are swapped at
the crossover point.

A header is 16*128 bytes long and contains up to 16
subheaders. Assuming that we have N subheaders SH0..SHN containing
secrets SK0..SKN, the header is constructed by appending headers
SH0..SHN together and with some random padding to achieve a total size
of 126*16 bytes. Then, each subheader key is used to create a key
Hash(SharedSecret, ``HEADER SECRET KEY'') with which the part of the
header after the subheader (but including its address extension) is
encrypted with using the stream cipher. 

(In practice headers and subheaders are constructed in parallel since
the Digest contained in the subheader is a hash of all the other
encrypted subheaders and the random data they generate as the message
travels through the network. )

PROCEDURE: Create a single header.

Inputs: A_1 .. A_N (addresses of intermediate nodes), 
	PK_1 .. PK_N (Public keys of intermediate nodes),
	SK_1 .. SK_N (Secret keys to be shared with intermediate nodes),
        R Routing type and information of last header (FWD, DROP, SWAP, etc.)
Output: H (The header)

Process: 
  // Calculate the sizes of the subheaders
  for i = 1 .. N
	SIZE_i = Len(ESHS(PK_i, V, SK_i, Z(16), Z(1), A_i))

  // Calculate the Junk that will be appended during processing:
  J_0 = ``'';
  for i = 1 .. N
	J_i = ( J_(i-1) | PRNG(HASH(SK_i, ``RANDOM JUNK'')[0:16], SIZE_i)
	J_i = J_i XOR PRNG(HASH(SK_i, ``HEADER SECRET KEY''),
  		Len(128*16))[128*16 - Len(J_i):Len(J-i)];
  end

  // Create the Header
  H_(N+1) = J[0: 128*16 - sum(SIZE_1 .. SIZE_N)];
  for i = N .. 1
	K = HASH(SK_i, ``HEADER SECRET KEY'')[0:16];
  	DIGEST = HASH( PRNG(K,Len(H_(N+1)) XOR H_(N+1) | J_i)
	if i = N then (set appropriate routing type)
	H_i = ESHS(PK_i, V, SK_i, DIGEST, F, A_i) | PRNG(K,Len(H_(N+1))) XOR H_(N+1)
  end

return H_1;

\subsection{The Payload of messages}

The payload of a Mixminion message has a fixed length of 32 kb
- 2*16*128 bytes = 28kb.   Payloads indicate their size.

  [XXXX Shouldn't size info go into the header, or no place?  Size
     info makes tagged payloads distinguishable from garbage. -NM]
  [XXXX Size info is quite important as well as some type information.
     Maybe in order to minimise the potential for tagging we should
     encrypt the payload using an encryption key specified in the
     reply block. So the reply block would be (SURB, encryption key,
     first hop, deadline). That would make us waste another 128 bytes
     of payload. -GD]

Size:   2 bytes
Data:   (Variable)

We denote a payload as P.

\subsection{Constructing whole messages}

Given two headers and a payload one can construct a whole
message. The first header (main) must always contain a last subheader
with routing type SWAP.  

PROCEDURE: Construct a message.

Input: H1 (header containing keys SK1_1... SK1_N)
       and H2 (header containing keys SK2_1... SK2_N.  Keys are unused
            if we're using a reply block.)
       P (Payload)
Output: M (the message)

Process:
	// Phase 1
	if (H2 is *not* a reply block)
		for i = N .. 0
	            P = SPRP_ENC(SK2_i, "PAYLOAD ENCRYPT", P)
		end
        else
           [ XXXX what do we use for H2 if we're not using a reply
	           block? -NM ]
	   [ XXXX The above processing is only happening if it is NOT
	a reply block. Otherwise it is impossible to know the keys
	SK2_i. For a reply block there is no other processing]

	// Phase 2
	H2 = SPRP(P, ``HIDE HEADER'', H2)

	for i = N .. 1
		H2 = SPRP_ENC(SK1_i, "HEADER ENCRYPT",H2)
		P = SPRP_ENC(SK1_i, "PAYLOAD ENCRYPT",P)
	end

\section{Processing of Messages}

Messages are transfered from node to node using the custom Type III
transport protocol or email.  A node with private key PK receiving
message M = (H1, H2, P) performs the following operations:

PROCEDURE: Process a message M
	SHS(V, SK, D, F, A) = PK_Decrypt(PK,H1[0:128]);
	If there is any problem with the OAEP padding discard the message.
	If the routing info spans across many blocks extract them and
		decrypt them.
	Check that D = H(H1[128:15*128]);
	H1 = H1[128:15*128] | PRNG(HASH(SK, ``RANDOM
						JUNK'')[0:16])[0:128];
	H1 = H1 XOR PRNG(HASH(SK, ``HEADER SECRET KEY''), Len(H1));
	H2 = SPRP_DEC(SK, ``HEADER ENCRYPT'',H2);
	P = SPRP_DEC(SK, ``PAYLOAD ENCRYPT'',P);

	if routing type is is DROP:
                End.
	if routing type is SWAP-FWD:
		H2 = SPRP_DEC(P, ``HIDE HEADER'', H2)
		Swap H1 and H2;
        if routing type is SWAP-FWD or FWD:
	   	Put (H1, H2, P) in queue to be sent to A.
        Otherwise:
		Give (A, H(SK,``APPLICATION KEY''), (H1, H2, P)) to
		Module manager. 
                  [XXXX Why does the application need H1 and H2? - NM]

\section{Single Use Reply Block exchange formats}

[It should contain, use-by date, first hop address, 
 SURB block, public key, etc.
 We can also have a short hand notation for SURBS that only
 use part of the header. One only needs to specify the 
 blocks containing the SURB and a key to pad the junk]

\section{Email Transport exchange format}

[Need to specify how we are going to wrap the message
 as an email. This is only intended for SURB use and
 we should think more carefully about providing a 
 general SMTP/IMAP service.
 There is a need to provide enough information to be 
 able to block the service, for the recipient and to
 filter out messages arriving from the mix network.]

\subsection{Replay Avoidance}

The nodes MUST implement a mechanism to make sure that messages cannot
be replayed. To do this a hash of the secret contained in the
subheader is kept for as long as the as public key under which it was
encrypted is in use. The Hash should be computed in the following way:

X = H(SharedSecret, ``REPLAY PREVENTION'')

The value X is not secret, and its secrecy should not be relied upon.
The integrity of the list should be secured and the X values lists may
be made public.

\section{Type III (Mixminion) forward secure protocol}

[cut + paste from other document]

A special channel should be established between mixes that provides
forward secrecy making it impossible to recognize or decrypt any
message that went through it in the past. In order to establish this
channel one of the two mixes initiates the connection but at the end
of the key exchange protocol the channel is bi-directional. The
protocol should be used when the SWAP-FWD/IP4 or FWD/IP4 address type
is specified in a subheader.

The Mixminion protocol uses TLS (the IETF standardization of SSL) with
the ciphersuite "TLS_DHE_RSA_WITH_AES_128_CBC_SHA" (defined in
tls-ciphersuite-03.txt).  No other ciphersuite is permitted for
MIX-to-MIX communications.

  [XXXX Do we want to use DHE_DSS instead? -NM]

  [XXXX We don't use AES256 because (a) it doesn't seem to be in
        the works for OpenSSL 0.9.7, and (b) all our other AES
        operations use 128-bit blocks and keys. -NM]

X.509 certificates need not be signed; instead, they must only contain
a key matching that used in the KEYID portion of the header's routing
data.  

Messages are sent from client to server; the client must send a
ClientHello packet to renegotiate session key between all
messages. [XXXX why so often? -NM] If the client does not do so, the
server must close the connection.  [XXXX Is this so? -NM]

[XXXX If there is a key updating operation between every message it means
that every message is encrypted under a different key. It also
provides a very small time window for someone breaking down your door
in order to decrypt what you have just transmitted. Is there a problem
with having it so often? -GD]

Protocol outline: (Portions marked with '*' are normative; other
portions are non-normative descriptions of TLS.)

\begin{verbatim}
- A invents a new Diffie Hellman key 
  (of at least 1024 bits modulus)
  and makes a certificate signed by her signing key.
  A then initiates the SSL Handshake protocol with B.
- B invents a DH key and makes a certificate using his signing
  key.
* A checks that the Hash of the signing key is the same as
  the one contained in the routing info of the subheader.
- The SSL handshake protocol proceeds as normal until a session
  key has been established. All communications are then encrypted
  using this session key.

* A sends "PROTOCOL 1.0", NL.  This indicates the highest protocol
  version A supports.
* If B is not willing to use any protocol A supports, B closes the 
  connection.

  B sends "PROTOCOL 1.0", NL.  This indicates B's choice of protocol.

  If A is not willing to support B's choice, A closes the connection.
  
* A sends "SEND", M, H(M,"SEND") (4 + 32k + 20 bytes)
* B sends "RECEIVED", H(M,"RECEIVED") (8 + 20 bytes)

* A sends an SSL handshake renegotiation message.
  (and MUST not reuse the same key for 
   transfering another message)
  This updates the session key and overrides the old ones.
\end{verbatim}

\emph{Note:}

The old keys must be permanently overwritten. Special care should be
taken to permanently erase them from the Hard Disk and memory. 

The standard transport mechanism over which the MixMinion Transfer
Protocol is TCP over IP. The standard listening TCP port should be 
number 48099 (until we register a port with www.iana.org)

[Q Should we request a system (<1023) or user port -GD]
[Q System ports can only be opened by root. we should avoid needing
to be root. -RD]
[Q I imagine it's hard to register a port with iana. Let's wait on
that til everybody takes us seriously. -RD]

All possible checks should be performed during the transfer protocol
and if any fail the connection MUST stop and all state MUST
be deleted. An error MAY be logged. In particular, if the address
hash element in the Master Header is nonzero, the certificate of
the communication partners must be signed using a key that hashes
appropriately.

\section{Remailer Information Exchange format}

[Need to provide signature + encryption keys, expiry dates, root of
list of hashes, Address, services and modules, policies, ...]

\section{Statistics Information Exchange formats}

[Stats, reputation, ... Roger?]

Accessing directory server?

Uploading blocks

Signing blocks ????

Receiving a reply?

Sending SMTP

Local delivery

