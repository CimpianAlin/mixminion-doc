\title{Type III (Mixminion) MIX Protocol Specifications}

\section{Message Format}

\subsection{Overview}

Type III (Mixminion) MIX messages are composed of a header section and a
payload.  The header section has a main header and a
secondary header, both of which have identical structure.  Each
header is further composed of up to 16 subheaders, which are
addressed and encrypted to the intermediate nodes (MIXes).  We
begin by explaining how the full message is structured but starting
with the smallest building block.

\subsection{Definitions and cryptographic primitives}

- if B is a byte array, B[i:j] (j bytes) is sub array starting at 
  byte i with length j.
- R(n) (n bytes) Generates n random bytes by any secure method.
[XXXX is R(n) ever used in the rest of the spec? Remove it? -RD]
- Z(n) (n bytes) Generates n zero bytes.
- Len(M) (2 bytes) is the length of message M (* bytes).
- x|y (Len(x)+Len(y) bytes) denotes x concatenated with y.

- PAD(M,L) (L bytes) pads the message M (Len(M) <= L) to length L
  using zeroes.
- H(M) (20 bytes) is the SHA-1 hash of M (* bytes).
[XXXX dangerous -- later you use H as a header. Perhaps use HASH
  and KHASH? In any case we need to put the keyed-hash-function
  from Lioness into this primitives section too. -RD]
- PK_Encrypt(K,M) (128 bytes) The RSA-encryption of a header M 
  using the public key K.  M is padded using RSA-OAEP, and encoded
  with PKCS1.
- PK_Decrypt(K,M) (up to 86 bytes) Gives the decryption of the
  message M (128 bytes) under the private key corresponding to K.
- Encrypt(K,M) (Len(M) bytes) Rijndael encryption (in Counter mode,
  with 128-bit blocksize) of message M using key K.  (All Rijndael
  operations use 128-bit blocks.)
- Decrypt(K,M,i,j) (j-i bytes) Rijndael counter mode decryption 
  using the key material byte i to j.
- PRNG(K, n) (n bytes) Uses Rijndael in counter mode to produce N
  bytes of pseudo-random numbers.
  PRNG(K, n) = Encrypt(K, Z(n))
- SPRP_ENCRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Uses a super-pseudorandom
  permutation to encrypt M with keys K1-K4.  Specifically, we use LIONESS,
  as described in XXXXCITE, with PRNG(K,n) as our stream generator,
  and the keyed-SHA1 construction specified in the LIONESS paper.

  K1 through K4 are 160 bits long.

  Thus, SPRP_ENCRYPT(K1,K2,K3,K4,M) is computed as follows:
            L := M[0:20]
            R := M[20:len(M)-20]
            R := ENCRYPT( H(K1 | L | K1)[0:16], R)
            L := L xor H(K2 | R | K2)
            R := ENCRYPT( H(K3 | L | K3)[0:16], R)
            L := L xor H(K4 | R | K4) 
            return L | R

  For convenience, we write SPRP_ENC(MS,P,M) to denote:
    [XXXX not clear what MS is. Master secret I presume? Can we pick a
       better variable? -RD]
       LIONESS_ENCRYPT(K1,K2,K3,K4,M)
       where K=HASH(MS | P)
             K1 = K
             K2 = K xor 0x00...01
             K3 = K xor 0x00...02
             K4 = K xor 0x00...03

- SPRP_DECRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Inverts SPRP_ENCRYPT.

  We also define SPRP_DEC(K,P,M) as the inverse of SPRP_ENC.
    
RSA encryption and decryption is used with OAEP padding, using the 
mask function MGF1 and hash function SHA1.  The security
[XXXX this is a different P from the other one. Can we call it the
'OAEP security parameter' (is that accurate?)? -RD]
parameter P is set to be the hash of the following 84-character ASCII
string (a quotation from Thomas Paine): 

     "He who would make his own liberty secure, must guard even his
      enemy from oppression." 

(Though weaknesses have been found in OAEP's original security proofs,
they seem not to appear when you're using RSA.)

All fields are packed in Internet (MSB first) order.

All RSA encryption uses the public exponent 65535.

\subsection{The subheader structure and address extensions}

A subheader contains all the information that a MIX needs to check the
integrity of a message and route it through the Internet. The subheader
is encrypted using RSA after having been padded using OAEP, using a 1024
bit key. This results in an encrypted block of 128 bytes.

A subheader contains the following fields:

Subheader fields:

V   Version Major:   1 byte
V   Version Minor:   1 byte
SK  Shared Secret:   16 bytes
D   Digest:          20 bytes
RS  Routing Size:    2 bytes 
RT  Routing Type:    2 bytes [total 42 bytes]
RI  Routing Info:    [Routing Size] bytes

* The Version is used to manage concurrent versions of the
protocol. If a packet is received with a version that is not supported
it must be discarded. Nodes must advertise in their status blocks what
versions of the protocol they support; see below.

* The Shared Secret is the base secret that is used to generate all
other keys for the operations the node performs on the packet. It must be
kept secret and discarded as soon as the packet has been processed. 

* The Digest contains an integrity check of the remainder of the current
header (128*15 bytes in total). The digest does not cover the current
subheader: modifications to it are detected because of the OAEP padding.

* The Routing Type defines how the MIX should deliver or relay the
  message. If a MIX receives a routing type it does not recognize,
  it must discard the message.

  Most routing methods require additional addressing information.
  The Routing Size field indicates the total size of the Routing
  Information. If the information is too long to fit in a single
  subheader (more than 86-42=44 bytes), then one or more additional
  Routing Extension blocks have to be added. These additional blocks
  must be 128 bytes each and should have the following structure:
 
  Routing Extension:

    Address Data:     Variable
    Padding:          Variable

* The address data length is specified by the ``Routing Size'' field
  contained in the subheader.
* The final Routing Extension block is padded with zeroes so it is
  exactly 128 bytes.

The Routing Extension(s) corresponding to a particular subheader are
appended to the subheader, and encrypted along with the rest of the
subheaders.

We will formally refer to the subheader structure as:
SHS(V, SK, D, RS, RT, RI)     [MIN(86, 42+Len(RI)) bytes] 
And to the RSA-OAEP encrypted portions of the subheader structure as:
ESHS(PK, V, SK, D, RS, RT, RI)   [128 bytes]
And to the extension blocks for a given subheader as:
EXT(RI)                       [Ceil((Len(RI)-44)/128) * 128 bytes]

\subsection{Routing information}

There are 5 predefined routing types:

0x0000-0x00FF: PROTOCOL SUPPORT

0x0000 DROP    (0 bytes of routing information)
0x0001 FWD/IP4 (IP: 4 bytes, PORT: 2 bytes, KEYID: 20 bytes): 26 bytes
0x0002 SWAP-FWD/IPV4 (same info as FWD/IP4)

0x0100-0x0FFF: PREDEFINED DELIVERY TYPES.

0x0100 SMTP   (EMAIL ADDRESS: variable, TAG: variable) Variable bytes
0x0101 LOCAL  (USER: variable, TAG: variable) Variable bytes

0x1000-0xEFFF: UNALLOCATED

0xF000-0xFFFF: FOR EXPERIMENTAL USE

A DROP routing type indicates a dummy message. It must be discarded.

A FWD/IP4 routing type indicates that the message must be
retransmitted using the TLS/Mixmaster transport protocol. The IP field
represents the IPv4 address.  The KEYID field represents the hash of
the next node's transport public key.

[XXXX Are the TLS keys different from the keys used to encrypt the
      headers?  I claim they should be. -NM]
[XXXX YES! They have to be different since they are discarded after
      the key exchange. The signature/verification key pair can be
      used for both purposes (signing ephemeral keys, and signing the
      mix encryption keys). -GD]
[XXXX That's not what I meant:  Is a server's RSA key that it uses 
      for decrypting headers, the same RSA key as key it uses for
      MMTP (as hashed in KeyID.)?  I still say yes... -NM]
[XXXX The hashed KEY ID is the verification key that is used to sign
      both the MMTP Ephemeral keys and (if we want) the long term
      decryption keys of the mix. -GD]
[XXXX Actually, it would be easier, and a little less paranoia-engendering,
      if the keys were different.  As I see it, a Mix should have 3
      public keys:
              1  A medium-term connection key that it uses for MMTP.
              2  A medium-term mix key that it uses to decrypt 
                 its subheaders.
              3  A long-term ``identity'' key that signs descriptor
                 blocks containing the first 2.
         Having '3' be different from '1' or '2' is a clear choice; 
         IMO '2' should be different from '1' because:
                a) I may be paranoid, but I don't like the idea of 
                   using the same key for signing stuff and decrypting
                   stuff.  It makes me think of adaptive attacks.
                b) It's easier to implement that way: Keeping non-SSL 
                   RSA keys separately from SSL RSA keys makes things
                   more modular.
                c) It costs us nothing in performance, except when
                   we generate new keys.
             -NM]

A SWAP routing type tells the node to exchange headers as described below.

The EMAIL field in the SMTP routing type should be a valid mailbox
[RFC2821]. A mailbox is the canonical form of the ``user@domain''
part of an e-mail address. Mixminion uses only mailboxes, because the
display name and comment parts of an e-mail address could potentially be
different for senders who have obtained an address from different
sources (leading to smaller anonymity sets). The EMAIL field must be
NUL-terminated.

The TAG field is appended to the message in an X-Remailer-Tag header.

The LOCAL routing type is used for messages to be delivered to a local
user.  The USER field must be NUL-terminated; the TAG field is
free-form.

(Tag fields can be used to implement stateless reply blocks by
reminding recipients of the master secrets they used to generate the
reply block.)

[XXXX Where has the RTRN type gone? I guess you can do the same job
with the LOCAL field but I would prefer to have it specified as a
separate type in the standard. 

0x0101 RTRN  (HOPS: 1 byte , KEY: 20 bytes) : 21 bytes -GD]

[XXXX Hm.  I'd rather not have 2 types that do exactly the same thing.
      Perhaps RTRN should behave differently, or LOCAL should have a
      type field of its own.

      As things stand above, you can do stateless return delivery with
      either of SMTP or LOCAL; neither is more "returny" than the other.

      Would it solve your concerns to add a type field to LOCAL? -NM]
[XXXX Ok, here is my real concern: I do not want every different client
      to implement their own version of the stateless reply block, in
such a way that they cannot interoperate. So I would rather have some 
standard fields containing the HOPS and KEY information along with any
other variable information. -GD]
[XXXX Ok, I agree with your goal of standardizing stateless replies,
      but I think they should go into a section on 'How to do
      stateless replies', so they can be orthogonal to SMTP/LOCAL/Foo  

      Proposed text:
         If a client does not wish to remember all of her outstanding
         reply blocks, she may generate them in 'stateless' mode.  She  
         does so by using an SMTP or LOCAL delivery type, and setting
         the TAG field to 
              (nHops | E(seed, sha1(password) | pad up to 32b.
[XXXX what's E? -RD]

         She uses PRNG(seed, nHops*16) to form the SK's in the reply
[XXXX why *16? What are you trying to do here. -RD]
         block, and to reconstruct them later when she receives the 
         message.
[XXXX should specify an order for reconstruction. looks dangerous
  without keeping the seed secret? -RD]
       
         If the client has complete trust in the final hop, she may
         use a null password.  Beware, however: an attacker who recovers 
         the seed can use it to link any of the hops along the reply 
         chain.

	 To keep replies indistinguishable from encrypted/tagged
         forwards, we set the TAG field of SMTP/Local to =exactly=
         32 bytes.

         Sound ok?                                 -NM ]

[XXXX I would add a type field for identification, and I think it is
ok -GD]

[XXXX That's interesting. My first thought would have been to PK-encrypt
      the hop secrets to the recipient. So not even a (separate) password
      needs to be remembered. But I guess that takes up a lot of
      space. -RD]

[XXXX Speaking of which, exactly 32 bytes of what? it looks like the
      above proposed 'tag' format has some recognizable plaintext? So
      we may need to PK-encrypt it anyway, or otherwise make it always
      plausible? -RD]


\subsection{The header structure}

Each type III message has two headers with identical structure. These
headers are swapped at the crossover point.

A header is 16*128 bytes long and contains up to 16
subheaders. Starting with N subheaders SH0..SHN containing secrets
SK0..SKN (and placing routing extension blocks directly after their
respective subheaders), the header is constructed by appending 
random padding to achieve a total size
of 128*16 bytes. Then, each subheader key is used to create a key
Hash(SharedSecret, ``HEADER SECRET KEY'') with which the part of the
header after the subheader (but including its routing extension) is
encrypted using the stream cipher. 
[XXXX not a stream cipher. Encrypt()? -RD]

(In practice headers and subheaders are constructed in parallel since
[XXXX in parallel? i don't get it. -RD]
the Digest contained in the subheader is a hash of all the other
encrypted subheaders and the random data they generate as the message
travels through the network.)

PROCEDURE: Create a single header.

Inputs: A_1 .. A_N (addresses of intermediate nodes), 
	PK_1 .. PK_N (Public keys of intermediate nodes),
	SK_1 .. SK_N (Secret keys to be shared with intermediate nodes),
        R Routing type and information of last header (FWD, DROP, SWAP, etc.)
Output: H (The header)

Process: 
  // Calculate the sizes of the subheaders
  for i = 1 .. N
	SIZE_i = Len(ESHS(PK_i, V, SK_i, Z(20), Z(1), 0, 0, RT_i))
[XXXX                                           Z(2)?    RT_i, 0?
  I'm not sure how to initialize these. Bigger picture, why not just
  say 128? -RD]
                    + Len(EXT(RI_i))

  // Calculate the Junk that will be appended during processing:
  J_0 = ``'';
  for i = 1 .. N
	J_i = ( J_(i-1) | PRNG(HASH(SK_i, ``RANDOM JUNK'')[0:16], SIZE_i)
	J_i = J_i XOR PRNG(HASH(SK_i, ``HEADER SECRET KEY''),
  		128*16)[128*15 -Len(J_i) + SIZE_i:Len(J_i)];
[XXXX                       16? -RD]
  end

  // Create the Header
  H_(N+1) = J[0: 128*16 - sum(SIZE_1 .. SIZE_N)];
[XXXX There is no J. J_n? -RD]
  for i = N .. 1
	K = HASH(SK_i, ``HEADER SECRET KEY'')[0:16];
	IF i = N (set appropriate routing type and A_i)
	EH = EXT( RI_i )
  	DIGEST = HASH( Encrypt(K, EH | H_(N+1)) | J_i ) )
[XXXX                                  H_(i+1)?
  We've got too many parens here too. -RD]
	H_i = ESHS(PK_i, V, SK_i, DIGEST, F, len(RI_i), RT_i, RI_i)
                  || Encrypt(K, EH | H_(N+1))
  end

return H_1;

\subsection{The Payload of messages}

The payload of a Mixminion message has a fixed length of 32 kb
- 2*16*128 bytes = 28kb.   Payloads indicate their size.

  [XXXX Shouldn't size info go into the header, or no place?  Size
     info makes tagged payloads distinguishable from garbage. -NM]
  [XXXX Size info is quite important as well as some type information.
     Maybe in order to minimise the potential for tagging we should
     encrypt the payload using an encryption key specified in the
     reply block. So the reply block would be (SURB, encryption key,
     first hop, deadline). That would make us waste another 128 bytes
     of payload. -GD]
  [Example body encryption: Apply LIONESS on the whole body of the
     message using a predefined key (K = 0x00...00). Encrypt the first
     128 bytes of the payload using an RSA encryption key contained in
     the reply block information. That way the payload looks random
     and only the final receipient can decrypt it (need to include a
     nonce and a digest in the body of the payload as well). BUT we
     have the problem that the key can be changed by the adversary in
     the reply block ... -GD Any comments?]
  [No, I'm afraid I don't know what to do here, or who, exactly is
     transmitting or encrypting what in your proposal.  Keep in mind 
     that generating RSA keys is the single most expensive operation
     in our system.
 
     Wait a minute... are we sure there's a problem at all?  Consider
     what an attacker would see at the last hop =without size info=:
                            REPLY          FORWARD 
          TAGGED MSG     Payload=opaque  Payload=opaque 
          UNTAGGED MSG   Payload=opaque  Payload= Plaintext 

     And =with= size info, so long as it gets LIONESSED with the
     rest of the message...
                            REPLY          FORWARD 
          TAGGED MSG     Payload=opaque  Payload=opaque 
          UNTAGGED MSG   Payload=opaque  Payload=Plaintext with size

     So the problem only seems to arise when you strip the payload
     padding at the server.  But how does the server know not do
     do this with reply payloads anyway?

     I'm just confused here. -NM]
[XXXX See discussion on the mailing list about payload encryption -GD]

Size:   2 bytes
Data:   (Variable)

We denote a payload as P.

\subsection{Constructing messages}

Given two headers and a payload one can construct a
message. The first header must contain a subheader
with routing type SWAP.  

PROCEDURE: Construct a message.

Input: H1 (header containing keys SK1_1... SK1_N)
       and H2 (either a header containing keys SK2_1... SK2_N if
         we constructed it, or a header with unknown keys if we're
         using a reply block.)
       P (Payload)
Output: M (the message)

Process:
	// Phase 1
	if (H2 is *not* a reply block)
		for i = N .. 1
	            P = SPRP_ENC(SK2_i, "PAYLOAD ENCRYPT", P)
		end
        else
           [ XXXX what do we use for H2 if we're not using a reply
	           block? -NM ]
	   [ XXXX The above processing is only happening if it is NOT
	a reply block. Otherwise it is impossible to know the keys
	SK2_i. For a reply block there is no other processing]
           [ XXXX Ah!  Perhaps, then, there should be a third
	          procedure that breaks down the relationship between
                  ``Construct a message'' here and ``create a single header''
                  above. -NM]
	// Phase 2
	H2 = SPRP_ENC(SHA1(P), ``HIDE HEADER'', H2)

	for i = N .. 1
		H2 = SPRP_ENC(SK1_i, "HEADER ENCRYPT",H2)
		P = SPRP_ENC(SK1_i, "PAYLOAD ENCRYPT",P)
	end

\section{Processing of Messages}

Messages are transferred from node to node using either the custom Type
III transport protocol (see below) or email.  A node with private key
PK receiving message M = (H1, H2, P) performs the following operations:

PROCEDURE: Process a message M
	SHS(V, SK, D, RS, RT, RI) = PK_Decrypt(PK,H1[0:128]);
        If there is any problem with the OAEP padding discard the message.
        Check that D = H(H1[128:15*128]), and discard if not.
        Let n_extra = number of extended headers = Ceil( (RS-44) / 128 )
                  
        H1 = H1[128:15*128] | PRNG(HASH(SK, "RANDOM 
                                               JUNK")[0:16],128+128*n_extra)
	H1 = H1 XOR PRNG(HASH(SK, "HEADER SECRET KEY")[0:16], Len(H1))
        RI = RI | H[0:128*n_extra]
        H1 = H1[128*n_extra:128*16]
	H2 = SPRP_DEC(SK, ``HEADER ENCRYPT'',H2);
	P = SPRP_DEC(SK, ``PAYLOAD ENCRYPT'',P);

	if routing type is DROP:
                End.
	if routing type is SWAP-FWD:
		H2 = SPRP_DEC(SHA1(P), ``HIDE HEADER'', H2)
		Swap H1 and H2;
        if routing type is SWAP-FWD or FWD:
	   	Put (H1, H2, P) in queue to be sent to the address in RI.
        Otherwise:
		Give (RT, RI, HASH(SK,``APPLICATION KEY''), P) to
[XXXX what use could hashing it first be? too dangerous to give SK
  directly? -RD]
		Module manager. 

\section{Single Use Reply Block exchange formats}

[It should contain, use-by date, first hop address, 
 SURB block, public key, etc.
 We can also have a short hand notation for SURBS that only
 use part of the header. One only needs to specify the 
 blocks containing the SURB and a key to pad the junk -GD]
 [But SURBs should use the whole header, otherwise they're
  leaking length info? -RD]


A SURB can be encoded in a standard binary or ASCII format.

Binary Format:

Begin Marker: 4 bytes
Version: 2 bytes
Address Size: 2 bytes
Address Type: 2 bytes
Address: (Address Size) bytes
Use-by-Date: 4 bytes
SURB size: 2 bytes
SURB data: (SURB size) bytes
Filler Key: 20 bytes
Linked Data Size: 2 bytes
Linked Data: (Linked Data Size) bytes
Digest: 20 bytes

Total: 54 bytes + Address Size + SURB size + Linked Data Size

* The magic marker contains the ASCII 4-byte string 'SURB'. 
* The version number contains the format version of the SURB.
  (should be 1 and 0 for this standard)
* Address: Contains the address of the first hop to which the message
  encoded using this SURB should be sent to.
   [ XXXX Won't the first hop always be a forward address?  If so, then
     we don't need the size marker: we only need an IP, port, and
     keyid.  If not, then we need a routing type as well. -NM ]
   [ XXXX I would rather have a consistent addressing scheme
          throughout. Is that causing any problems? Added an address 
          type as well. -GD]
* Use-by-Date: indicated the expiry date the SURB should be used by. Can
  be calculated using the key rotation frequencies of the intermediate
  nodes.
   [ XXXX Units? If we're too fine-grained, people may use this to
     leak info.  If we're too course-grained, we can't move to a
     tighter schedule later on.  -NM]
   [ XXXX Should we have it in days since a magic date? -GD]
* SURB data: Containst the SURB that is created as described
  above. The Junk at the end can be omited (although it is not wise
  to reduce it more than half the size of a full SURB). When the SURB
  is created some data can be bound to it to ensure that they cannot
  be replaced by any malicious third party. To do this instead of 
  including junk at the end of the SURB one can include a hash of the
  data: 
	H(Address, Use-by-Date, Linked Data)
  That hash is contained in the last 20 bytes of the SURB data.
* Filler: Used to prinme the stream cipher to pad the SURB data up to
  128*16 bytes.

    [ XXXX Why not just always include the junk?  It'd be easier, and
       omitting the junk never saves more than 1K per SURB. -NM]
    [ XXXX True. Leaving the Junk also does not give away any
       information about the real length of the message. I included
       this possibility because 16 hops is actually quite a lot and 1k
       in a message of 32k could be significant (particularly is more
       than one SURB have to be transported). -GD]

* Linked Data: Additional data that might have to be linked with the 
  SURB.
    [ XXXX Hm.  What is the point of this? Leaving it free-form raises
      issues of linkability.  I suggest that rather than adding a
      catch-all hook, we just embed SURBs when we want to embed
  them. -NM]
    [ XXXX The rationale for including this additional data is the
  following: we might want to associate a public encryption key or
  someting else with the address itself, so the hash needs to be
  included before the junk. It is better to have a standard place to
  hold and encode this additional data otherwise everyone will be
  finding a different method for doing it. -GD]

* The Digest is a Hash of all the other fields.
    [ XXXX Why have a digest here?  What is the risk?  Anybody who can
       tamper with a SURB can recompute the digest.  -NM ]
    [ XXXX This is not a security feature, this is a reliability
       one. As the SURBs are transported over email (that can be
  commented etc) it is better if they can be checked as valid. Could
  just be a CRC. Is is nice if it is a hash since we are sure it is
  difficult to find another SURB that hashes to the same ID. -GD]

The ASCII Encoding of SURBs.

The  ASCII compatible format of SURB's is:

--- BEGIN SURB ---
Version: x.x
ID: Base64 Encoding of the first 48 bits of the Digest (8 characters).
Base64 encoded binary SURB 
--- END SURB ---

The version number should be in decimal ASCII and is the same as the
binary version.

[ XXXX This should absolutely have a version number.  Again, what does
  the digest defend against? -NM]
[ XXXX It is not a security feature but an ID that uniquely identifies
  this SURB. Can be used by applications that manage SURBs to refer to
  them, and as a 8 character short hand if you want to address an
  email to the SURB -GD]

\section{Email Transport exchange format}

This format should be used when the SMTP address type is used for a
message. The SMTP address is specified in the ``EMAIL ADDRESS'' field,
and the ``TAG'' FIELD should be included in the SMTP header after as
``X-Remailer-Tag'' filed.

The Reply-to field should contain the email address which can be used
to block service to the receipient. The body should also clearly
indicate how the procedure of blocking oneself works.

--- BEGIN ANONYMOUS MESSAGE ---
VERSION: x.x
ID: 48 first bits of the hash of the whole binary message.
Base64 encoded mixminion packet (32kb long -> 44 kb long)
--- END ANONYMOUS MESSAGE ---

The subject line should read: ``Anon. Message: '' + ID

[Need to specify how we are going to wrap the message
 as an email. This is only intended for SURB use and
 we should think more carefully about providing a 
 general SMTP/IMAP service.
 There is a need to provide enough information to be 
 able to block the service, for the recipient to
 filter out messages arriving from the mix network.]

\subsection{Replay Avoidance}

The nodes MUST implement a mechanism to make sure that messages cannot
be replayed. To do this a hash of the secret contained in the
subheader is kept for as long as the public key under which it was
encrypted is in use. The Hash should be computed in the following way:

X = H(SharedSecret, ``REPLAY PREVENTION'')

The value X is not secret, and its secrecy should not be relied upon.
The integrity of the list should be secured and the X values lists may
be made public.

\section{Type III (Mixminion) forward secure protocol}

A special channel should be established between mixes that provides
forward secrecy making it impossible to recognize or decrypt any
message that went through it in the past. In order to establish this
channel one of the two mixes initiates the connection but at the end
of the key exchange protocol the channel is bi-directional. The
protocol should be used when the SWAP-FWD/IP4 or FWD/IP4 address type
is specified in a subheader.

The Mixminion protocol uses TLS (the IETF standardization of SSL) with
the ciphersuite "TLS_DHE_RSA_WITH_AES_128_CBC_SHA" (defined in
tls-ciphersuite-03.txt).  No other ciphersuite is permitted for
MIX-to-MIX communications.

X.509 certificates need not be signed; instead, they must contain
a key matching that used in the KEYID portion of the header's routing
data.  

Messages are sent from client to server; the client must send a
ClientHello packet to renegotiate session key between all
messages. [XXXX why so often? -NM] If the client does not do so, the
server must close the connection.  [XXXX Is this so? -NM]

[XXXX If there is a key updating operation between every message it means
that every message is encrypted under a different key. It also
provides a very small time window for someone breaking down your door
in order to decrypt what you have just transmitted. Is there a problem
with having it so often? -GD]

Protocol outline: (Portions marked with '*' are normative; other
portions are non-normative descriptions of TLS.)

\begin{verbatim}
- A invents a new Diffie Hellman key 
  (of at least 1024 bits modulus)
  and makes a certificate signed by her signing key.
  A then initiates the SSL Handshake protocol with B.
- B invents a DH key and makes a certificate using his signing
  key.
* A checks that the Hash of the signing key is the same as
  the one contained in the routing info of the subheader.
- The SSL handshake protocol proceeds as normal until a session
  key has been established. All communications are then encrypted
  using this session key.

* A sends "PROTOCOL 1.0", NL.  This indicates the highest protocol
  version A supports.
* If B is not willing to use any protocol A supports, B closes the 
  connection.

  B sends "PROTOCOL 1.0", NL.  This indicates B's choice of protocol.

  If A is not willing to support B's choice, A closes the connection.
  
* A sends "SEND", NL, M, H(M,"SEND") (5 + 32k + 20 bytes)
* B sends "RECEIVED", NL, H(M,"RECEIVED") (9 + 20 bytes)

* A sends an SSL handshake renegotiation message.
  (and MUST not reuse the same key for 
   transfering another message)
  This updates the session key and overrides the old ones.
\end{verbatim}

\emph{Note:}

The old keys must be permanently overwritten. Special care should be
taken to permanently erase them from the Hard Disk and memory. 

The standard transport mechanism over which the MixMinion Transfer
Protocol talks is TCP over IP. The standard listening TCP port should be 
number 48099 (until we register a port with www.iana.org)

All possible checks should be performed during the transfer protocol
and if any fail the connection MUST stop and all state MUST
be deleted. An error MAY be logged. In particular, if the address
hash element in the Master Header is nonzero, the certificate of
the communication partners must be signed using a key that hashes
appropriately.

\section{Remailer Information Exchange format}

[Need to provide signature + encryption keys, expiry dates, root of
list of hashes, Address, services and modules, policies, ...]

[A more comprehensive list of things that the Remailer information
needs to provide:

Status: Serial Number, Supercedes, Timestamp created, timestamp to
        refresh, urgency (revokation, routine ...)	  
Address and names: IP Address, TCP Port, Name of Owner, e-mail of
                   admin, trust domain(s) 
RSA Long Term Verification Public Key of server: e, n, timestamp,
                   hash(e, n, IP, Port). (next key hash)
RSA Short Term Encryption Public Key: e, n, timestamp, Hash(...)
Network Services: MixMinion Protocols supported.
		  MMTP Protocols supported.
	          SMTP Support flag, address restrictions.
                  LOCAL Support flag, mailbox restrictions.
	          IP addresses it will accept and send to.
Modules: Modules supported, configurations.
Trust Management: Hash of the State of the world as the mix knows it at
        that point. This can be the hash of a whole tree:

		           H
             / =           |                   = \
	Internal                               External
 /=                  =\                     /=        =\
Logs of           Previous keys          Other Mix    ...
Seen messages     and config +stats       Per Day
|   |    |   |    |   |   |  ...          |   |   |
Day Day ...  Day  ...
1   2        x


Assuming that mixes talk to each ther every day and some know, and
trust, each others verification keys we create a ``headless''
certification infrastructure. Since not all the mixes are going to
revoke their verification keys in the same day it is possible to 
check that the historic information (and stats) across the network has
not been modified. (there is only the need to reveal the hashes from a
node to the head of the tree to check the validity of the information).

\section{Statistics Information Exchange formats}

[Stats, reputation, ... Roger?]

Accessing directory server?

Uploading blocks

Signing blocks ????

Receiving a reply?

Sending SMTP

Local delivery

