\title{Type III (Mixminion) Mix Protocol Specifications}

\section{UNRESOLVED ISSUES}

[All of these are mentioned in more detail below.]

1. Mail gateways. We should specify these.
   [Should go into appendix]
   [Agreed.  We should make an actual list of appendices that we
    need, and start writing them all.-NM]

2. Description of mixing algorithm should go in descriptor blocks. -NM
   [XXXX Unless the mixing method requires special packaging of the message 
         we could require the servers to specify the amount of anonymity that
         they expect to give to each message. The information theoretic one
         presented by myself and Andrei could do the job quite well. -GD]

3. We should specify: are 'DROP'-type messages dropped before they go
    into the mix pool, or after they're pulled from the pool?

  [Before. -NM]
  [My feeling is After, but I should think about it... -GD]
  [Roger seemed pretty sure that it should be 'before', but I don't
   remember why.  Roger? -NM

4. We should specify: what happens when a message is undeliverable?

  [We retry for a while, then drop it. -NM]
  [Specifically: we retry the message with subsequent message pools
   until it is delivered, or until a certain amount of time has
   passed. -NM]

5. "End-to-end" issues

  [I've added a revised version of my E2E note to the repository. -NM]
  [Looked at the E2E document, and I think it is v.good. We need to update 
   the main specs to be in conformance with it. I quite like the fact that 
   they are separate documents, since the one can be used to implement a
   "pure" server and the other a client or an "impure server" -GD]
  [If by 'pure' you mean 'relay', yes.  But implementing things like
   SMTP exit nodes requires that a server be able to decode messages
   properly. -NM]

6. K-of-N delivery or fragments.
    [I believe this is covered by the E2E spec -GD]
    [Yes, but we don't actually specify the erasure algorithm.  I'm
     currently leaning towards the one using Vandermonde matrices with
     values from GF(2^n), but it isn't actually specified at a byte
    level anywhere but its own source code. -NM]

7. Path selection algorithm.

\section{FUTURE ISSUES}
(These are unresolved issues that we don't want to think about till we
have more stuff done.)

1. Statistics Information Exchange format
   [Not for first cut]
2. Specify: verification for directories.
   [not for first cut]
   [Actually, we may need these first two pieces for Mixminion 1.0;
    else we won't be deployable. -NM]
3. When do dummy messages get generated?
   [Current hypothesis: As a first cut, we're going to have nodes add
    dummies to the outgoing batch every mix interval, with a geometric
    distribution, with 5 hops, with the sender as the last hop. -NM]
4. When does link padding get generated?
   [Both active research areas; not for first cut]

5. Automatic retrieval of Server Information
[XXXX I think it is important to have a standard way to query a server given 
      an IP and a port. -GD]
[Why? What's wrong with having the server upload its information to a
 directory server? (Not that I disagree, but I want to know the
 application for this.  Clients can't use it without leaking which
 servers they're interested in, and giving servers the opportunity to
 lie to clients.  What's the upside?) -NM]
[I believe that this will make it more easy to construct Directory servers. 
 For some reason I have the feeling that it will scale better if directory 
 servers know about mixes (and can query them automatically) rather than the 
 other way around (mixes knowing about directory servers). This way one can 
 run independently a directory server, without any collaboration from the mix
 network (other than the ability to request info). 

 Let's not forget that the
 mixes *sign* their information with a long term key, therefore after you 
 establish that you trust a signing key to belong to an honest server, the 
 operation of querying a directory server for updates is simply a question 
 of transport and not of trust. Of course you still trust them to give you a 
 information on a complete set of servers, but this can also be checked. 
 It is also true that the a client requesting only the information on the 
 servers it is about the use will ruin its anonymity. On the other hand if key
 updates are not frequent, then the client can slowly update its database in 
 the background.

 Even more possibilities open up if each mix server give on request not only 
 their information but also what they think the state of other servers, they 
 have contacted in the past, is. This way each server you might contact will 
 give you a set of other servers, that can be used by clients to construct a 
 complete picture. Which ones are to be trusted is of course an orthogonal 
 issue, but once it is decided the updated information could flow very 
 quickly. (this is in fact a gossip protocol)

 These are the reasons why I think it might be a good idea to have automatic 
 on request information from servers. -GD]
[Hm.  You may have a point.  I'm still going to suggest that we do
 not do this yet, for a few reasons.

 First, we need a way for servers to publish their descriptors to
 directory servers.  (Otherwise, a directory server couldn't learn
 about new servers for the first time.)  In other words, a push
 mechanism is needed no matter what.  On the other hand, directory
 servers may or may not need a pull mechanism: we do not yet have a
 design that requires this.  Let's not build it till we have a use
 for it.

 Second, it's a bit tricky to specify *which* descriptor a server
 should return.  Today's?  Tomorrow's?  All the ones it knows about?

 Third, (this is a variant of 'First') because client use of this
 feature is prone to misuse, we should only provide it to clients
 wrapped in some safe mechanism.  That safe mechanism has yet to be
 specified.

 Therefore, I'm going to suggest that we call this feature possibly
 desirable... but that we should first design directories or whatever
 other node discovery mechanisms *may* want this feature before we
 decide that to implement the feature itself. -NM]

\section{Message Format}

\subsection{Overview}

Type III (Mixminion) Mix messages are composed of a header section and a
payload.  The header section has a main header and a
secondary header, both of which have identical structure.  Each
header is further composed of up to 16 subheaders, which are
addressed and encrypted to the intermediate nodes (mixes).  We
begin by explaining how the full message is structured by starting
with the smallest building block.

\subsection{Definitions and cryptographic primitives}

- if B is a byte array, B[i:j] (j bytes) is sub array starting at 
  byte i with length j.
- Rand(n) (n bytes) Generates n random bytes by any secure method.
- Z(n) (n bytes) Generates n zero bytes.
- Len(M) (2 bytes) is the length of message M (* bytes).
- x|y (Len(x)+Len(y) bytes) denotes x concatenated with y.

- PAD(M,L)=M|Z(L-Len(M)) (L bytes) pads the message M (Len(M) <= L)
  to length L using zeroes.
- HASH(M) (20 bytes) is the SHA-1 hash of M (* bytes).
- PK_Encrypt(K,M) (128 bytes) The RSA-encryption of a header M 
  using the public key K.  M is padded using RSA-OAEP, and encoded
  with PKCS1.
- PK_Decrypt(K,M) (up to 86 bytes) Gives the decryption of the
  message M (128 bytes) under the private key corresponding to K.
- Encrypt(K,M) (Len(M) bytes) Rijndael encryption (in Counter mode,
  with 128-bit blocksize) of message M using key K.  (All Rijndael
  operations use 128-bit blocks.)  The Initial Vector (IV) is Z(16).
- Decrypt(K,M,i,j) (j-i bytes) Rijndael counter mode decryption 
  using the key material byte i to j.
- PRNG(K, n) (n bytes) Uses Rijndael in counter mode to produce N
  bytes of pseudo-random numbers.
  PRNG(K, n) = Encrypt(K, Z(n))
- SPRP_ENCRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Uses a super-pseudorandom
  permutation to encrypt M with keys K1-K4.  Specifically, we use LIONESS,
  as described in XXXXCITE, with ENCRYPT(K,m) as our stream cipher,
  and the keyed-SHA1 construction specified in the LIONESS paper.

  [XXXX I think we can get away with BEAR instead.  See my email of
    September 6. -NM I agree -GD]
  [XXXX Okay.  Whose approval were we waiting for to get final
    verification of this?  Was it David Hopwood? -NM]

  K1 through K4 are 160 bits long.

  Thus, SPRP_ENCRYPT(K1,K2,K3,K4,M) is computed as follows:
            L := M[0:20]
            R := M[20:len(M)-20]
            R := ENCRYPT( HASH(K1 | L | K1)[0:16], R)
            L := L xor HASH(K2 | R | K2)
            R := ENCRYPT( HASH(K3 | L | K3)[0:16], R)
            L := L xor HASH(K4 | R | K4) 
            return L | R

  For convenience, we write SPRP_ENC(SK,P,M) to denote:
       SPRP_ENCRYPT(K1,K2,K3,K4,M)
       where K=HASH(SK | P)
             K1 = K
             K2 = K xor 0x00...01
             K3 = K xor 0x00...02
             K4 = K xor 0x00...03

- SPRP_DECRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Inverts SPRP_ENCRYPT.

  We also define SPRP_DEC(K,P,M) as the inverse of SPRP_ENC.

RSA encryption and decryption is used with OAEP padding, using the
mask function MGF1 and hash function SHA1.  The security parameter (P
in the OAEP spec) is set to be the hash of the following 84-character
ASCII string (a quotation from Thomas Paine):

     "He who would make his own liberty secure, must guard even his
      enemy from oppression." 

(Though weaknesses have been found in OAEP's original security proofs,
they seem not to appear when you're using RSA.)

All fields are packed in Internet (MSB first) order.

All RSA encryption uses the public exponent 65537.

\subsection{The subheader structure and address extensions}

A subheader contains all the information that a mix needs to check the
integrity of a message and route it through the Internet. The subheader
is encrypted using RSA after having been padded using OAEP, using a 1024
bit key. This results in an encrypted block of 128 bytes.

A subheader contains the following fields:

Subheader fields:

V   Version Major:   1 byte
V   Version Minor:   1 byte
SK  Shared Secret:   16 bytes
D   Digest:          20 bytes
RS  Routing Size:    2 bytes 
RT  Routing Type:    2 bytes [total 42 bytes]
RI  Routing Info:    [Routing Size] bytes

* The Version is used to manage concurrent versions of the
protocol. If a packet is received with a version that is not supported
it must be discarded. Nodes must advertise in their status blocks what
versions of the protocol they support; see below.

* The Shared Secret is the base secret that is used to generate all
other keys for the operations the node performs on the packet. It must be
kept secret and discarded as soon as the packet has been processed. 

* The Digest contains an integrity check of the remainder of the current
header (128*15 bytes in total). The digest does not cover the current
subheader: modifications to it are detected because of the OAEP padding.

* The Routing Type defines how the mix should deliver or relay the
  message. If a mix receives a routing type it does not recognize,
  it must discard the message.

  Most routing methods require additional addressing information.
  The Routing Size field indicates the total size of the Routing
  Information. If the information is too long to fit in a single
  subheader (more than 86-42=44 bytes), then one or more additional
  Routing Extension blocks have to be added. These additional blocks
  must be 128 bytes each and should have the following structure:
 
  Routing Extension:

    Address Data:     Variable
    Padding:          Variable

* The address data length is specified by the "Routing Size" field
  contained in the subheader.
* The final Routing Extension block is padded with zeroes so it is
  exactly 128 bytes.

The Routing Extension(s) corresponding to a particular subheader are
appended to the subheader, and encrypted along with the rest of the
subheaders.

We will formally refer to the subheader structure as:
SHS(V, SK, D, RS, RT, RI)     [MIN(86, 42+Len(RI)) bytes] 
And to the RSA-OAEP encrypted portions of the subheader structure as:
ESHS(PK, V, SK, D, RS, RT, RI)   [128 bytes]
And to the extension blocks for a given subheader as:
EXT(RI)                       [Ceil((Len(RI)-44)/128) * 128 bytes]

\subsection{Routing information}

There are 5 predefined routing types:

0x0000-0x00FF: PROTOCOL SUPPORT: NON-EXIT TYPES

0x0000 DROP    (0 bytes of routing information)
0x0001 FWD/IP4 (IP: 4 bytes, PORT: 2 bytes, KEYID: 20 bytes): 26 bytes
0x0002 SWAP-FWD/IPV4 (same info as FWD/IP4)
0x0003 FWD/IP6 (IP: 16 bytes, PORT: 2 bytes, KEYID: 20 bytes): 38 bytes
0x0004 SWAP-FWD/IPV6 (same info as FWD/IP6)

0x0100-0x0FFF: PREDEFINED DELIVERY TYPES.

0x0100 SMTP   (TAG: 20 bytes, EMAIL ADDRESS: variable) Variable bytes
0x0101 MBOX   (TAG: 20 bytes, USER: variable) Variable bytes
0x0102 MIX2   (EMAIL ADDRESS: variable).  Type II remailer support.

0x1000-0xEFFF: UNALLOCATED

0xF000-0xFFFF: FOR EXPERIMENTAL USE

A DROP routing type indicates a dummy message. It must be discarded.
To prevent servers from distinguishing among clients, every DROP
message should have a random payload.

A FWD/IP4 routing type indicates that the message must be
retransmitted using the TLS/Mixminion transport protocol. The IP field
represents the IPv4 address.  The KEYID field contains the SHA1 hash
of the ASN.1 representation of the next node's identity public key.

A SWAP routing type tells the node to exchange headers as described below.

The FWD/IP6 and SWAP-FWD/IP6 routing types are analogous to FWD/IP4
and SWAP-FWD/IP4, except that they use IPv6 addresses rather than IP4
addressed.  [Path generation in this case is an open issue. -NM]

See appendices for more information about SMTP and MBOX delivery.

\subsection{The header structure}

Each type III message has two headers with identical structure. These
headers are swapped at the crossover point.

A header is 16*128 bytes long and contains up to 16
subheaders. Starting with N subheaders SH_0..SH_N containing secrets
SK_0..SK_N (and placing routing extension blocks directly after their
respective subheaders), the header is constructed by appending 
random padding to achieve a total size
of 128*16 bytes. Then, each subheader key is used to create a key
Hash(SharedSecret | "HEADER SECRET KEY") with which the part of the
header after the subheader (but including its routing extension) is
encrypted using counter-mode AES.

We construct the subheaders from last to first, so that each can contain
a digest of the subsequent subheaders and padding data.

PROCEDURE: Create a single header.

Inputs: A_1 .. A_N (addresses of intermediate nodes), 
        PK_1 .. PK_N (Public keys of intermediate nodes),
        SK_1 .. SK_N (Secret keys to be shared with intermediate nodes),
        R Routing type and information of last header (FWD, DROP, SWAP, etc.)
Output: H (The header)

[XXXX We need to define RI_i and RT_i above; A_i is never really
   used. -NM]

Process: 
  // Calculate the sizes of the subheaders
  for i = 1 .. N
        SIZE_i = 128 + Len(EXT(RI_i))

  // Calculate the Junk that will be appended during processing:
  J_0 = "";
  for i = 1 .. N
        J_i = J_(i-1) | PRNG(HASH(SK_i | "RANDOM JUNK")[0:16], SIZE_i)
        Stream_i = PRNG(HASH(SK_i | "HEADER SECRET KEY"), 128*15 + SIZE_i);
        J_i = J_i XOR Stream_i[128*15 -Len(J_i) + SIZE_i:Len(J_i)];
  end

  // Create the Header
  H_(N+1) = Rand(128*16 - sum(SIZE_1 .. SIZE_N));

  for i = N .. 1
        K = HASH(SK_i | "HEADER SECRET KEY")[0:16];
        IF i = N (set appropriate routing type and A_i)
        EH = EXT( RI_i+1 )
        REST = Encrypt(K, (EH | H_(i+1)))
        DIGEST = HASH(REST | J_i-1)
        H_i = ESHS(PK_i, V, SK_i, DIGEST, len(RI_i+1), RT_i+1, RI_i+1) | REST
  end

return H_1;

\subsection{The Payload of messages}

The payload of a Mixminion message has a fixed length of 32 kb
- 2*16*128 bytes = 28kb.   Payloads indicate their size.

(When sending a reply message with a SURB, we use payload encryption
to prevent the crossover point from seeing an unencrypted payload. See
the 'end-to-end encoding' spec for more information.)

We denote a payload as P.

\subsection{Constructing messages}

Given two headers and a payload one can construct a
message. The first header must contain a subheader
with routing type SWAP.  

PROCEDURE: Construct a message.

Input: H1 (header containing keys SK1_1... SK1_N)
       and H2 (either a header containing keys SK2_1... SK2_N if
         we constructed it, or a header with unknown keys if we're
         using a reply block and a SURB secret key.)
       P (Payload)
Output: M (the message)

Process:
        // Phase 1
        if (H2 is a reply block)
                P = SPRP_ENC(SURB secret key, "PRIVATE SURB KEY", P)
        else // (H2 is *not* a reply block)
                for i = N .. 1
                        P = SPRP_ENC(SK2_i, "PAYLOAD ENCRYPT", P)
                end
        endif
        // Phase 2
        H2 = SPRP_ENC(SHA1(P), "HIDE HEADER", H2)
        P = SPRP_ENC(SHA1(H2), "HIDE PAYLOAD", P)

        for i = N .. 1
                H2 = SPRP_ENC(SK1_i, "HEADER ENCRYPT",H2)
                P = SPRP_ENC(SK1_i, "PAYLOAD ENCRYPT",P)
        end
        M = (H1, H2, P)

\section{Processing of Messages}

Messages are transferred from node to node using either the custom Type
III transport protocol (see below) or email.  A node with private key
PK receiving message M = (H1, H2, P) performs the following operations:

PROCEDURE: Process a message M
        SHS(V, SK, D, RS, RT, RI) = PK_Decrypt(PK,H1[0:128]);
        If there is any problem with the OAEP padding discard the message.
        Check that D = HASH(H1[128:15*128]), and discard if not.
        Let n_extra = number of extended headers = Ceil( (RS-44) / 128 )
                  
        H1 = H1[128:15*128] | PRNG(HASH(SK | "RANDOM 
                                               JUNK")[0:16],128+128*n_extra)
        H1 = H1 XOR PRNG(HASH(SK, "HEADER SECRET KEY")[0:16], Len(H1))
        RI = RI | H[0:128*n_extra]
        H1 = H1[128*n_extra:128*16]
        H2 = SPRP_DEC(SK, "HEADER ENCRYPT",H2);
        P = SPRP_DEC(SK, "PAYLOAD ENCRYPT",P);

        if routing type is DROP:
                End.
        if routing type is SWAP-FWD:
                P = SPRP_DEC(SHA1(H2), "HIDE PAYLOAD", P)
                H2 = SPRP_DEC(SHA1(P), "HIDE HEADER", H2)
                Swap H1 and H2;
        if routing type is SWAP-FWD or FWD:
                Put (H1, H2, P) in queue to be sent to the address in RI.
        Otherwise:
                Give (RT, RI, HASH(SK, "APPLICATION KEY"), P) to
                Module manager.

The "Application Key" is provided to the module as a shared secret
between the constructor of the header and the module that is in charge
of processing it.  The hash step above prevents the module from using
the master secret Sk in any way that could inadvertently compromise
its other functions (such as the decryption of the unlinkability of
the message).

\section{Single Use Reply Block exchange formats}

A SURB can be encoded in a standard binary or ASCII format.

Binary Format:

   Begin Marker: 4 bytes
   Version:      2 bytes
   Use-by-Date:  4 bytes
   SURB header:  2048 bytes
   Routing Size: 2 bytes
   Routing Type: 2 bytes
   Encryption key: 16 bytes
   Routing Info: (Routing Size) bytes

   Total: 30 bytes + Header size + Routing info size.

* The begin marker is the ASCII 4-byte string 'SURB'. 
* The version number contains the format version of the SURB.
  (should be hex 01 and 00 for this standard).
* Routing type/routing size/routing info: Defined as in subheaders.
  These fields encode the address of the hop which the SURB user should
  use as an exit point.
* Use-by-Date: indicates the expiry date the SURB should be used by. Can
  be calculated using the key rotation frequencies of the intermediate
  nodes.  This field must be given as a number of seconds since
  midnight GMT on Jan 1, 1970 -- but must be aligned to the start of a
  day (in other words, it must be divisible by 60*60*24).
  (Misaligned dates must be rejected as invalid.)

  (Rationale: a seconds-level granularity allows us to move to a
  tighter schedule later on in order to support a synchronous mixnet.)

* SURB data: Contains the SURB that is created as described above.
* Encryption key: used to LIONESS-encrypt the payload before sending it
  into the network.  

The ASCII Encoding of SURBs.

The  ASCII compatible format of SURBs is:
======= BEGIN TYPE III REPLY BLOCK ========
Version: x.x
Base64 encoded binary SURB 
======== END TYPE III REPLY BLOCK =========

The version number should be in decimal ASCII and is the same as the
binary version.

\section{Replay Avoidance}

The nodes MUST implement a mechanism to make sure that messages cannot
be replayed. To do this a hash of the secret contained in the
subheader is kept for as long as the public key under which it was
encrypted is in use. The Hash should be computed in the following way:

X = HASH(SharedSecret | "REPLAY PREVENTION")

The value X is not secret, and its secrecy should not be relied upon.
The integrity of the list should be secured and the X values lists may
be made public.

\section{Type III (Mixminion) forward secure protocol}

A special channel should be established between mixes that provides
forward secrecy making it impossible to recognize or decrypt any
message that went through it in the past. In order to establish this
channel one of the two mixes initiates the connection but at the end
of the key exchange protocol the channel is bi-directional. The
protocol should be used when the SWAP-FWD/IP4 or FWD/IP4 address type
is specified in a subheader.

Servers must not connect to themselves over the network when routing
packets to their own published IP/Port combination.

The Mixminion protocol uses TLS (the IETF standardization of SSL) with
the ciphersuite "TLS_DHE_RSA_WITH_AES_128_CBC_SHA" (defined in
tls-ciphersuite-03.txt).  No other ciphersuite is permitted for
mix-to-mix communications.

[Servers must allow incoming connections via SSL3_RSA_DES_192_CBC3_SHA
for clients written with older SSL libraries.  However, servers must
never initiate connections with this suite.]

The X.509 certificate must be signed by the server's identity
key, and a certificate containing the server's identity key must be
included with the certificate chain set to the client.  If the
identity key doesn't match the KEYID portion of the  header's routing
data, the client closes the connection.

Messages are sent from client to server.  Session suspension is not
permitted.

Protocol outline: (Portions marked with '*' are normative; other
portions are non-normative descriptions of TLS.)

\begin{verbatim}
- A invents a new Diffie Hellman key 
  (of at least 1024 bits modulus)
  and makes a certificate signed by her signing key.
  A then initiates the SSL Handshake protocol with B.
- B invents a DH key and sends a certificate chain containing:
   - a certificate with B's transport public key, signed by B's
     identity key. 
   - a self-signed certificate containing B's identity key.
* A checks that the Hash of the identity key is the same as
  the one contained in the routing info of the subheader.
- The SSL handshake protocol proceeds as normal until a session
  key has been established. All communications are then encrypted
  using this session key.

* A sends "MMTP 1.0", CRLF.  This indicates the protocol versions that
  A supports.

  (Future clients that support more protocols should transmit
   "MMTP ", a list of comma-separated protocol versions, and a CRLF.)

* If B is not willing to use any protocol A supports, B closes the 
  connection.

  B sends "MMTP 1.0", CRLF.  This indicates B's choice of protocol.

  If A is not willing to support B's choice, A closes the connection.

* Message case:

     * A sends "SEND", CRLF, M, HASH(M|"SEND") (6 + 32k + 20 bytes)
     * B sends "RECEIVED", CRLF, HASH(M|"RECEIVED") (10 + 20 bytes)

    [Note that A does not wait for B's reply before sending further
     messages; rather, A begins sending its next message immediately.
     Node A waits until the reply is received, however, before
     removing the message from its local storage.  Node A pauses,
     however, if it is waiting for 16 hashes at a time.]

* Padding case:

     * A sends "JUNK", CRLF, Junk, HASH(Junk|"JUNK") (6 + 32k + 20 bytes)
       (where Junk is an arbitrary 32k sequence.)
     * B sends "RECEIVED", CRLF, HASH(Junk|"RECEIVED JUNK") (10 + 20 bytes)

       [Note that both cases require the same number of bytes and 
        processing time. Implementations must make sure the real message 
        and the padding cases are indistinguishable to a third party, or
        even to the parties involved after the keys have been
        updated.]

* Error case:

     * A sends "SEND", CRLF, M, HASH(M|"SEND") (6 + 32k + 20 bytes)
     * B sends "REJECTED", CRLF, HASH(M|"REJECTED") (10 + 20 bytes)
    
       [B must reject a message if their hash is incorrect; if the
        disk is full, or if for some other reason B cannot accept the
        message.  Again, implementations should not be distinguishable
        in their timing in the case where the message is accepted or
        rejected.  When A receives a "REJECTED" reply, it must behave
        is if delivery had failed, and retry the message later (up to
        a reasonable retry interval).]

* If a connection persists for longer than 15 minutes, the client
  must initiate key renegotiation.  If it has not, the server must
  close the connection.

\end{verbatim}

\emph{Note:}

The old keys must be permanently overwritten. Special care should be
taken to permanently erase them from the Hard Disk and memory. 

The standard transport mechanism over which the MixMinion Transfer
Protocol talks is TCP over IP. The standard listening TCP port should be 
number 48099 (until we register a port with www.iana.org)

All possible checks should be performed during the transfer protocol
and if any fail the connection MUST stop and all state MUST
be deleted. An error MAY be logged. 

\section{Mix Information Exchange format}

In order to automate and standardize directory servers, we provide 
a standardized extensible server descriptor format.

All server descriptors and statistics blocks follow a simple
section-based key/value format, with items loosely based on RFC822.

[Section1]
Key: Value
Key: Value
Key: Value

Key: Value
Key: Value

[Section2]
Key: Value

\subsection{Syntax}

(Notation:  X*: 0 or more occurrences of X.
            X+: 1 or more occurrences of X.
            X?: 0 or 1 occurrences of X.
            X Y: An occurrence of X followed by an occurrence of Y.
            X*{Y}: 0 or more occurrences of X separated by occurrences
                  of Y.
            X|Y: Either an occurrence of X, or an occurrence of Y.)

Descriptor = NL Section+ 

Doctype = (<any printable character but '-'>)+

Section = SectionLine EntryLine*

SectionLine = '[' Word ']' NL+

EntryLine = Word ':' ' ' Data NL+

Word = (<Any printable, non-space character but ':'>)+

Data = (<Any printable character but NL>)*

[Note: For compatibility across different platforms, implementations must
  accept all of CR, LF, and CR-LF style newlines.]

\section{Mixminion descriptor blocks}

This section describes the format of server descriptors, as uploaded
to and downloaded from directory servers.  A server descriptor is a
promise, by a mix's administrators, to provide a given set of
services, keys, and exit policies over a set period of time.

The first section must be a 'Server' section.  This section includes
the entries:

     'Descriptor-Version':  the string "1.0"
     'IP': An IPv4 address, in dotted-quad format.
     'Nickname': A human-readable identifier for this server.  If it
         contains any periods, it must be a fully qualified DNS name
         which resolves to the provided IP for the entire lifetime of
         this Descriptor block.  It must be no more than 128
         characters.  It may contain only the characters 
         [A-Za-z0-9_@] and '-'.  It should be treated as
         case-insensitive.

     'Identity': The modulus of this Mix node's long-term signing key,
         represented in ASN.1, and encoded in BASE64.  The modulus of
         this key should be at least 2048 bits long and no more than
         4096 bits long.  The exponent of this key must be 65537.

         Clients should at least give a warning if the identity key of
         any server should ever change.
     'Digest': The digest of this block. See below.
     'Signature': The signed digest of this block.  See below.
     'Published': A date/time, in the form 'YYYY/MM/DD HH:MM:SS',
         for when this block was generated.
     'Valid-After': A date, in the form 'YYYY/MM/DD'.  After midnight GMT
         on this date, this server must support the operations listed
         in this descriptor.
     'Valid-Until': A date, in the form 'YYYY/MM/DD'.  Until midnight
         GMT on this date, this server must support the operations listed
         in this descriptor.
     'Contact': An email address that may be used to contact the
         administrator of this server. Optional field.  Must be no
         more than 256 characters.
     'Contact-Fingerprint': Fingerprint of the server administrator's
         PGP key. Optional field.  Must be no more than 128
         characters.
     'Comments': Human-readable information about this server.  Must
         be <1024 bytes long.  It *must not* be necessary to read this
         information to use the server properly.
     'Packet-Key': The public key used to encode encode subheaders for
         this server, encoded in ASN.1, represented in BASE64. 
     'Packet-Versions': A comma-separated list of allowable major.minor
         versions for packets this server will process.  In a
         production network, only one value should be used for this
         field. [Added in Mixminion 0.0.3 -NM]
     'Software': A string description of the software this server is
         running.  Optional; for debugging purposes only.  Must be
         less than 256 characters. [Added in Mixminion 0.0.3 -NM]
     'SecureConfiguration': "yes" or "no".  If true, the server must 
         not be running in an insecure operating mode. [XXXX list
         these modes.  Added in Mixminion 0.0.4]
 
The digest of a descriptor block is computed by removing the contents of the
digest and signature fields, and computing the SHA-1 digest of the resulting
ASCII string.  (That is, "Digest: DATADATADATA..." is replaced with
"Digest:".)  The signed digest is the OAEP/PKCS1 signature of the digest
with the server's identity key.  This value is represented in BASE64.

[Note: before computing the digest, all implementations must normalize CR and
CR-LF style newlines to a single NL, and remove any spaces and tabs that may
have been introduced at the ends of lines.]

If this server accepts incoming MMTP connections, it MAY have an
'Incoming/MMTP' section, with the following entries:

     'Version': The string '1.0'
     'Port': A port at which IP accepts incoming MMTP connections.
     'Key-Digest': The KEYID of this server, encoded in BASE64.
     'Protocols': A comma-separated list of the protocols this
           server accepts.

and any number of entries of the form:
     'Allow': Address Pattern
     'Deny': Address Pattern

If this server supports outgoing MMTP connections, it MAY have a
'Outgoing/MMTP' section, with one entry each of the form:

      'Version': The string '1.0'
      'Protocols': A comma-separated list of the protocols this server
           supports for outgoing connections.

and any number of entries of the form:

      'Allow': Address Pattern
      'Deny': Address Pattern

The Address Pattern tokens are of the form:

   AddressPattern = (IP ('/' Mask)? | '*') (Port ('-' MaxPort)?)?

'*' is a synonym for '0.0.0.0/0.0.0.0'.

An omitted mask defaults to 255.255.255.255.  An omitted portrange
defaults to 48099 on ALLOW and 0-65535 on DENY.

The entries are order-significant; the first one to match wins.

The default policy is 'Deny: *'

If this server supports outgoing delivery for a module ABCD, it will
have a [Delivery/ABCD] section.  See appendices for more detail on
specific modules, including SMTP and MBOX.

Other services provided by this server should each have their own section.

(Note: A server need not advertise all of its capabilities; it is
permissible (for example) for a server that supports incoming MMTP
connections to omit the Incoming/MMTP section.)

A client should ignore any keys or sections it does not recognize, but
should not use any service whose sections have an unrecognized
descriptor version.

\subsection{Directories and Directory servers}

A directory is a list of Mixminion servers which are believed to
be operational at a given time.

A directory server provides an HTTP URL for uploading server
descriptors, an HTTP URL for downloading a directory, and a long-term
public key (2048-4096 bits).

To upload a descriptor block, a client performs an HTTP POST request
to the upload URL, with the server block as enclosed entity.

To retrieve the directory, a client performs an HTTP GET request on
the directory URL.

A directory takes the following form:

 [Directory]
 Version: 1.0
 Published: YYYY/MM/DD HH:MM:SS
 Valid-After: YYYY/MM/DD
 Valid-Until: YYYY/MM/DD
 Recommended-Software: Mixminion 0.0.2,Mixminion 0.0.3
 [Signature]
 DirectoryIdentity: Base64-encoded public key, in ASN.1
 DirectoryDigest: Digest of this document.
 DirectorySignature: Base64-encoded OAEP/PKCS1 signature of this document, with
     the contents of this field removed.
 [Recommended-Software]
 ... (see below)
 [Server]
     (Server descriptor block)
 [Server]
     (Server descriptor block)

The 'Recommended-Software' section lists versions of Type-III clients
and servers that are currently recommended.  Because the version
numbering scheme will be different for each implementation, lines
within 'Recommended-Software' are version specific.  The "Mixminion"
program uses the entries 'MixminionClient' and 'MixminionServer'; each
contains a space-separated list of acceptable version numbers, in
order of decreasing preference.  If a client is running an
unrecommended version, it must warn the user.  [Policy: A development
version of Mixminion (pre 1.0) will only be declared obsolete when it 
is either too insecure or too buggy to use, when backward
compatibility is broken, or when a new stable release comes out.
Stable releases will be taken off the list only for security or
privacy reasons.]

Directory servers change their directories only at midnight GMT.  Any
client which has not downloaded a directory since before midnight GMT,
must download a fresh directory before generating any packets.

A directory includes all the servers that were uploaded to the
directory before some cutoff time the previous day, and which proved
upon some random number of tests and probings to have a real Mixminion
server running on them.  A directory server periodically re-tests
the servers in its directory to make sure they have not gone down.

Because of possible partitioning attacks related to accidentally or
maliciously unsynchronized servers, the presence of multiple directory
servers presents sever security issues.  Since solving these issues is
an active research project, we leave them for a later draft.


[XXXX Issues include:  How do directory servers synchronize?
   What happens when they disagree?  How many servers must a client
   contact before he/she has enough information?  How do we catch
   dishonest directory servers? -NM]

[XXXX We should also specify, perhaps, how directories are to order
   the server descriptors; what uniqueness constraints there are, and so
   on. -NM]

[XXXX Also: statistics information. Also: we should think about
   avoiding catastrophic failure modes if directories _do_ fail or
   change. -NM]

\section{Appendix: Pooling rule}

In order to allow room for future experimentation, we do not require a
single batching rule.  Nonetheless, we describe a recommended rule (as
used in Mixmaster) which is somewhat resistant to flooding attacks.
Implementors are strongly encouraged to use this algorithm, or another
equally robust against active and passive attacks.  (Be sure to read
\cite{batching-taxonomy}.)

PROCEDURE: Choose sets of messages to transmit ("Cottrell-style batching")

Inputs: Q (a queue of messages)
        N (the number of messages in the queue).
        MIX_INTERVAL (algorithm parameter; time to wait between
                      batches of messages.  Should be around
                      XXXXX. Must be >= 0.)
        POOL_SIZE (algorithm parameter; minimum size of pool.  Should
                   be at least XXXXXXXX.  Must be >= 0.)
        MAX_REPLACEMENT_RATE (algorithm parameter; largest allowable
                   rate for messages to be removed from the
                   pool. Should be between XXXX and XXXX.  Must have
                   0.0 < MAX_REPLACEMENT_RATE <= 1.0)

Outputs: (A set of messages sent to the network).

1. Wait for MIX_INTERVAL seconds.

2. If N > POOL_SIZE, then let 'max_send' = FLOOR(N*MAX_REPLACEMENT_RATE).
   [If 'max_send' < 0, let max_send = 1.]  Choose Min(N-POOL_SIZE, max_send)
   messages from Q.  Transmit the selected messages.

[XXXX Email from Peter Palfrader confirms the bracketed step above,
 which can only occur when MAX_REPLACEMENT_RATE < 0.  I'm going to
 suggest that we simply forbid MAX_REPLACEMENT_RATE < 0, and go back
 to the simplified version:
     Min(N-POOL_SIZE, FLOOR(N*MAX_REPLACEMENT_RATE)) -NM]

3. Repeat indefinitely.

[XXXX 
   Paul and/or Andrei describe a variant that checks N>=POOL_SIZE+THRESHOLD, 
   with THRESHOLD>= 1.  Roger claims (verbally) that he isn't sure whether
   this would buy us anything, since (he says) adding 1 to POOL_SIZE would
   always increase anonymity more than adding 1 to THRESHOLD.  Once they've
   come to some agreement, maybe we should do that instead.

   Then there are binomial mixes, where instead of sending b messages,
   you send each message with probability=b/POOLSIZE.  Roger/Paul/Andrei
   seem to like those, but I don't have a clear sense of how sure they are,
   and how much everyone agrees with them. -NM]
  
\section{Appendix: MBOX delivery}

Servers that want to support MBOX delivery have an internal list of
users they accept messages to, and an internal mapping from those
users to some delivery mechanism for each one.  Typically, this is a
mapping from 'username' to 'username@localhost', and delivery defaults
to local delivery via sendmail.  Servers are free to provide other
implementations for MBOX delivery.

MBOX delivery differs from SMTP delivery in that it is not intended
for addressing messages to arbitrary SMTP addresses.

Servers that support MBOX delivery MAY include a [Delivery/MBOX]
section, containing only the entry "Version: 1.0".

The MBOX routing type is used for messages to be delivered to a local
user.  The USER field must be NUL-terminated; the TAG field is
free-form. 

\section{Appendix: SMTP delivery}

[XXXX This paragraph is no longer accurate. -NM]
At the final hop, when the delivery mechanism is SMTP, we proceed as
follows.  If the message is a series of printable characters followed
by some number of NULs, assume we're delivering in ASCII an ISO-XXXX
character set, and send the text portion of the message as an email.
(Where printable == {all characters but hexadecimal 00-06,0E-1F}).
Otherwise, ASCII-armor the message as in 'email transport exchange
format' below.

[This way, plaintext forward messages are delivered as plaintext,
and tagged messages, reply messages, and non-plaintext messages are
all delivered as junk.]

Servers supporting SMTP MAY include a [Outgoing/SMTP] section,
containing only the entry "Version: 1.0".

Servers SHOULD include a note with every SMTP, explaining that the
message is delivered anonymously, and providing an opt-out address and
an abuse contact.

The EMAIL field in the SMTP routing type should be a valid mailbox
[RFC2821]. A mailbox is the canonical form of the "user@domain"
part of an e-mail address. Mixminion uses only mailboxes, because the
display name and comment parts of an e-mail address could potentially be
different for senders who have obtained an address from different
sources (leading to smaller anonymity sets). The EMAIL field must be
NUL-terminated.
[XXXX Be more specific about which mailboxes we allow -- e.g., forbid
  supremor@"whitehouse".gov and friends. -NM]

The TAG field is appended to the message in an X-Remailer-Tag header.
[XXXX Not now it isn't.  I need to rewrite this section to reference
the E2E spec. -NM]

[XXXX Until we have better answers about abuse prevention, nobody should
  actually implement an SMTP module. :) -NM]
[XXXX Actually, I already did.  Oops!  Let's say that an SMTP module
  should support, at least, the ability for the server operator to
  blacklist specific hosts, domains, usernames, and addresses. -NM]
[XXXX We need to reference the E2E spec here to explain how to
  encapsulate nonprinting messages consistently. -NM]

\section{Appendix: Backward compatibility with Type II remailers}

In order to share anonymity sets with Type III remailers while
retaining type II support, some remailers may wish to use Mixminion to
deliver type II messages.  This is done as follows:

Nodes that accept both type II and type III messages may advertise the
fact in their server descriptor by including a section of the form:
 
         [Incoming/Mix2]
         Address: (type II remailer's email address)
         Key: (type II key)
         KeyID: (type II keyid)
         Signature: (signature of identity key with type II key)
         (Optionally, KeyID and Signature repeated any number of
                      times.)

This section advertises that the mix can handle type II messages
intended for a given type II identity (email address) and set of keys.

The value of 'key' is the base-64 representation of the ASN.1 encoding
of the Mix node's type II key. The value of 'Signature' must be the
base-64 representation of the RSA-OAEP/PKCS1 signature (using the
type II remailer key) of the SHA-1 hash of the ASN.1 representation of
this node's identity key.

Directory servers and bridging nodes _must_ verify that keyid and
signature are correctly computed.

Upon receiving a type II message via SMTP, a bridging node checks
whether the destination node is also a type III node, by looking for a
type III node whose KeyID matches the KeyID for the packet. [See below]
If it finds one, the bridging node unbase64's the type II message's 
contents, and uses them (plus random padding) as the payload
of a type III message for that node.  The routing type must be 'MIX2'
(0x0102); the routing info must be equal to the destination mix's
type II address.

\subsection{Non-normative note: extracting KeyID and message contents}

(This information is included in the Type II remailer spec; it is included
here only for reference.)

A type II message follows the format:

"-----BEGIN REMAILER MESSAGE-----" NL
PacketLength NL
Checksum NL
Packet NL
"-----END REMAILER MESSAGE-----" NL

PacketLength is the length of the packet in bytes, encoded as a
decimal integer."Checksum" is equal to the MD5 hash of the packet,
encoded in Base 64.  The packet is also encoded in base 64; The first
16 bytes of the packet are the KeyID of the recipient.

The KeyID of a type II node is calculated by taking the public key
<n,e>, expressing n and e as zero-padded, big-endian integers,
concatenating them, and taking the MD5 hash of the result.

When encoding a type II message for transmission in a type III payload,
a type III node should include:

S   [2 bytes] (Size, big-endian)
CHK [16 bytes] (MD5 checksum as given in type II packet, base-64 decoded)
PKT [S bytes] (Packet as given in in type II packet, base-64 decoded)
PAD [28KB-16-2-S bytes] (Random padding)

\section{Appendix: Versioning and alphas}

Today's alpha code does not publish its version as '1.0'; it uses
'0.x' instead (currently '0.2' for packets, '0.2' for MMTP, and '0.1'
for everything else).  Production versions should *not* retain
backward compatibility with pre-production releases.
