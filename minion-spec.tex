\title{Type III (Mixminion) MIX Protocol Specifications}

\section{UNRESOLVED ISSUES}

[All of these are mentioned in more detail below.]


1. Is there any reason for the RECEIVED ack in MMTP?
1.5. Is the 'BAD SHA1' nak in MMTP acceptable?

   Proposal: keep them both. -NM
   Sounds good, until we hear from GD that they're unnecessary. :) -RD

   I do not think that cryptographically they are necessary, but they
   give the node a warm feeling that the other node is processing the
   message. Originally I thought we could provide a signature on a
   batch of them, so that the nodes can prove they have sent the
   messages. I do not think that anything breaks if we get rid of
   them. -GD]
 

2. Email encryption: what do we do?

   Proposal: SURBs include an encryption key; anonymous SURB-using
   senders LIONESS_ENCRYPT the payload with this key before all other
   processing.  This way, nobody but the recipient will see the
   plaintext of the message. [For stateless SURBs, the encryption key
   is derived from the seed like the rest of the secrets.] -NM

   And for non-anonymous SURB-using senders, the mail gateway they
   use does it for them when it takes the reply block and attaches their
   payload. -RD
   For non-anonymous SURBs the problem does not arise since the
   message never appears in clear exept at the begining of the trip
   -GD.

   Now the following problem occurs: when you receive a SURB, how do
   you know that the associated key is indeed the key that the creator
   of the SURB intended for you to use in order to encrypt the
   message. This is the reason why I thought that instead of using
   pure junk to pad SURBs to 16*128 bytes on can use the HASH of the
   public key. Therefore if you trust that the SURB you have goes to
   the right recipient (because of the hashes in the sub headers), 
   then you automatically trust the key that
   comes with it. (how to trust that you have the right SURB is
   another problem). -GD
   PLEASE see the ``The payload of a message'' section for a
   discussion of this as well as the archived messages:
   ``Payload encryption''
   http://archives.seul.org/mixminion/dev/May-2002/msg00060.html

2b. Mail gateways. We should specify these.

   XXXX

   I feel it should be part of a different standard. Since it is a
   service (like others) that runs on top of Mixminion. -GD

3. Email transport exchange format.

   Proposal: At the final hop, when the delivery mechanism is SMTP, we
   proceed as follows.  If the message is a series of printable
   characters followed by some number of NULs, assume we're
   delivering in ASCII or ISO-foo or whatever, and send the text
   portion of the message as an email.   (Where printable==
   {all characters but hexadecimal 00-06,0E-1F}).  Otherwise,
   ASCII-armor the message as in 'email transport exchange format'
   below.

   This way, plaintext forward messages are delivered as plaintext,
   and tagged messages, reply messages, and non-plaintext messages are
   all delivered as junk. -NM

   Sounds good for now. If our assumption that "a random 28kb payload
   will always contain at least one of these non-printable characters"
   turns out to not work so well, we can always back off to the "imbed
   the length with some redundancy" option from earlier. -RD

   We have to always include a header or footer explaining how to not
   receive anonymous messages in the future. To avoid being
   spammers. Generally (except in the case of the final hop of a SURB)
   I think that delivering SMTP should be an application level issue
   that is dealt in a different document along with how to send
   email. -GD

4. Stateless replies and SMTP (depends on 2 and 3, if I understand correctly)

   Proposal: stateless replies put E_recipient_key(nHops | seed) as
   the value of the LOCAL or SMTP Tag field, as suggested in my
   comments below.  (See comments for why.) -NM

   See http://archives.seul.org/mixminion/dev/Jul-2002/msg00003.html
   for more discussion. Should we pick one, or both? -RD

5. Do we support other SSL modes for MMTP?

   Proposal: server-to-server connections must use DHE/RSA/AES128/SHA1, 
   but we allow clients to connect with RSA/AES128/SHA1 and
   RSA/3DES/SHA1.  -NM

   I think this is ok. -RD
   Seems fine -GD
   
6. How often do/must we rehandshake?

   Proposal: see note in text. -NM
             Agree in the text -GD

7. Local delivery

   Proposal: Servers that want to support LOCAL delivery have an
   internal list of users they accept messages to, and an internal
   mapping from those users to some delivery mechanism for each one.
   Typically, this is a mapping from 'username' to
   'username@localhost', and delivery defaults to local delivery via
   sendmail.
       Servers are free to provide other implementations for local 
   delivery. -NM


8a. Server descriptor rules for Local mode

   Proposal: If a server supports LOCAL delivery, it MAY have a
   'Modules/Local' section, which contains only a version string,
   which must be "1.0". -NM

   I think it should be the other way around: 
	we have Incomming/MMTP so maybe rename to Outgoing/MMTP
        and create an Outgoing/SMTP descriptor.
        Then naturally you can have local services such as 
		Local/Mailbox
		Local/FreeHaven
		Local/NymServer
		Local/ListServ
	Acting as different service ports. -GD

8b. Server descriptor rules for SMTP mode.

   XXXX

9. When do dummy messages get generated?

   XXXX

10. When does link padding get generated?

   XXXX

   Question 9 + 10 are an active research area, and given that we
   provide meachanisms fo doing dummy messages and link padding we
   should not specify anything in the spec. -GD

11. Need to write: algorithm for processing a reply.

   XXXX

12. Support Diffs for directories?

    Proposal: not until later. -NM
    Agreed. They won't be "too big" anytime soon. -RD
    Agreed. -GD

13. Do we change directories to XML?  What about descriptor blocks?

    Proposal: Use XML for both. That's what it's there for. More
    specifically, we should make descriptors take EITHER the form:

    <mixminion-server>            <mixminion-server>
      <section>                      <section>
      key=val                           <key>val</key>
      key=val                           <key>val</key>
      </section>         OR          </section>        
      <section>                      <section>
      key=val                           <key>val</key>
      key=val                           <key>val</key>
      </section>                     </section>        
    </miximinion-server>         </mixminion-server>

    Which one is more sensible?  Beats me.  If we go for the latter,
    we probably don't want to have the configuration files correspond
    to the server info any more.  This may be a good thing.

    Also, will XML signatures serve our purposes? -NM

    I have no experiance with XML so as long as we can sign and trust
    the thing I have no problem with it. -GD

14. Sensible support for multiple directory servers.

    Proposal: save for for later. -NM
    Agreed. -RD
    Yes -GD

15. We should write the nymserver spec too. We can keep it pretty much
    separate from this Mixminion spec.
    I will start working on this as soon as I am back from Belgium (5
    Aug 02). I will try to put on paper the scribbles of the CFP
    napkins and additional issues. May be this is a better place to
    define general SMTP transport (except for last hop of SURB)
    instead of the general mixminion spec document. -GD

16. We'll also want somebody from the Mixmaster crowd to go through and
    write a "backward compatibility with Mixmaster" addendum, to specify
    what dual Mixmaster/Mixminion servers should do when they receive a
    given packet. (Len?)

    If we could have a hack so that both services can run as different
    binaries, it will be easier to phase out the mixmaster stuff. -GD

\section{Message Format}


\subsection{Overview}

Type III (Mixminion) MIX messages are composed of a header section and a
payload.  The header section has a main header and a
secondary header, both of which have identical structure.  Each
header is further composed of up to 16 subheaders, which are
addressed and encrypted to the intermediate nodes (MIXes).  We
begin by explaining how the full message is structured but starting
with the smallest building block.

\subsection{Definitions and cryptographic primitives}

- if B is a byte array, B[i:j] (j bytes) is sub array starting at 
  byte i with length j.
- Rand(n) (n bytes) Generates n random bytes by any secure method.
- Z(n) (n bytes) Generates n zero bytes.
- Len(M) (2 bytes) is the length of message M (* bytes).
- x|y (Len(x)+Len(y) bytes) denotes x concatenated with y.

- PAD(M,L) (L bytes) pads the message M (Len(M) <= L) to length L
  using zeroes.
- HASH(M) (20 bytes) is the SHA-1 hash of M (* bytes).
- PK_Encrypt(K,M) (128 bytes) The RSA-encryption of a header M 
  using the public key K.  M is padded using RSA-OAEP, and encoded
  with PKCS1.
- PK_Decrypt(K,M) (up to 86 bytes) Gives the decryption of the
  message M (128 bytes) under the private key corresponding to K.
- Encrypt(K,M) (Len(M) bytes) Rijndael encryption (in Counter mode,
  with 128-bit blocksize) of message M using key K.  (All Rijndael
  operations use 128-bit blocks.)
- Decrypt(K,M,i,j) (j-i bytes) Rijndael counter mode decryption 
  using the key material byte i to j.
- PRNG(K, n) (n bytes) Uses Rijndael in counter mode to produce N
  bytes of pseudo-random numbers.
  PRNG(K, n) = Encrypt(K, Z(n))
- SPRP_ENCRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Uses a super-pseudorandom
  permutation to encrypt M with keys K1-K4.  Specifically, we use LIONESS,
  as described in XXXXCITE, with PRNG(K,n) as our stream generator,
  and the keyed-SHA1 construction specified in the LIONESS paper.

  K1 through K4 are 160 bits long.

  Thus, SPRP_ENCRYPT(K1,K2,K3,K4,M) is computed as follows:
            L := M[0:20]
            R := M[20:len(M)-20]
            R := ENCRYPT( HASH(K1 | L | K1)[0:16], R)
            L := L xor HASH(K2 | R | K2)
            R := ENCRYPT( HASH(K3 | L | K3)[0:16], R)
            L := L xor HASH(K4 | R | K4) 
            return L | R

  For convenience, we write SPRP_ENC(SK,P,M) to denote:
       SPRP_ENCRYPT(K1,K2,K3,K4,M)
       where K=HASH(SK | P)
             K1 = K
             K2 = K xor 0x00...01
             K3 = K xor 0x00...02
             K4 = K xor 0x00...03

- SPRP_DECRYPT(K1,K2,K3,K4,M) (Len(M) bytes) Inverts SPRP_ENCRYPT.

  We also define SPRP_DEC(K,P,M) as the inverse of SPRP_ENC.

RSA encryption and decryption is used with OAEP padding, using the
mask function MGF1 and hash function SHA1.  The security parameter (P
in the OAEP spec) is set to be the hash of the following 84-character
ASCII string (a quotation from Thomas Paine):

     "He who would make his own liberty secure, must guard even his
      enemy from oppression." 

(Though weaknesses have been found in OAEP's original security proofs,
they seem not to appear when you're using RSA.)

All fields are packed in Internet (MSB first) order.

All RSA encryption uses the public exponent 65535.

\subsection{The subheader structure and address extensions}

A subheader contains all the information that a MIX needs to check the
integrity of a message and route it through the Internet. The subheader
is encrypted using RSA after having been padded using OAEP, using a 1024
bit key. This results in an encrypted block of 128 bytes.

A subheader contains the following fields:

Subheader fields:

V   Version Major:   1 byte
V   Version Minor:   1 byte
SK  Shared Secret:   16 bytes
D   Digest:          20 bytes
RS  Routing Size:    2 bytes 
RT  Routing Type:    2 bytes [total 42 bytes]
RI  Routing Info:    [Routing Size] bytes

* The Version is used to manage concurrent versions of the
protocol. If a packet is received with a version that is not supported
it must be discarded. Nodes must advertise in their status blocks what
versions of the protocol they support; see below.

* The Shared Secret is the base secret that is used to generate all
other keys for the operations the node performs on the packet. It must be
kept secret and discarded as soon as the packet has been processed. 

* The Digest contains an integrity check of the remainder of the current
header (128*15 bytes in total). The digest does not cover the current
subheader: modifications to it are detected because of the OAEP padding.

* The Routing Type defines how the MIX should deliver or relay the
  message. If a MIX receives a routing type it does not recognize,
  it must discard the message.

  Most routing methods require additional addressing information.
  The Routing Size field indicates the total size of the Routing
  Information. If the information is too long to fit in a single
  subheader (more than 86-42=44 bytes), then one or more additional
  Routing Extension blocks have to be added. These additional blocks
  must be 128 bytes each and should have the following structure:
 
  Routing Extension:

    Address Data:     Variable
    Padding:          Variable

* The address data length is specified by the ``Routing Size'' field
  contained in the subheader.
* The final Routing Extension block is padded with zeroes so it is
  exactly 128 bytes.

The Routing Extension(s) corresponding to a particular subheader are
appended to the subheader, and encrypted along with the rest of the
subheaders.

We will formally refer to the subheader structure as:
SHS(V, SK, D, RS, RT, RI)     [MIN(86, 42+Len(RI)) bytes] 
And to the RSA-OAEP encrypted portions of the subheader structure as:
ESHS(PK, V, SK, D, RS, RT, RI)   [128 bytes]
And to the extension blocks for a given subheader as:
EXT(RI)                       [Ceil((Len(RI)-44)/128) * 128 bytes]

\subsection{Routing information}

There are 5 predefined routing types:

0x0000-0x00FF: PROTOCOL SUPPORT

0x0000 DROP    (0 bytes of routing information)
0x0001 FWD/IP4 (IP: 4 bytes, PORT: 2 bytes, KEYID: 20 bytes): 26 bytes
0x0002 SWAP-FWD/IPV4 (same info as FWD/IP4)

0x0100-0x0FFF: PREDEFINED DELIVERY TYPES.

0x0100 SMTP   (EMAIL ADDRESS: variable, TAG: variable) Variable bytes
0x0101 LOCAL  (USER: variable, TAG: variable) Variable bytes

0x1000-0xEFFF: UNALLOCATED

0xF000-0xFFFF: FOR EXPERIMENTAL USE

A DROP routing type indicates a dummy message. It must be discarded.

A FWD/IP4 routing type indicates that the message must be
retransmitted using the TLS/Mixmaster transport protocol. The IP field
represents the IPv4 address.  The KEYID field contains the SHA1 hash
of the ASN.1 representation of the next node's transport public key.
(Note that a node's transport key does not need to be the same as the
key it uses to decrypt subheaders.)

A SWAP routing type tells the node to exchange headers as described below.

The EMAIL field in the SMTP routing type should be a valid mailbox
[RFC2821]. A mailbox is the canonical form of the ``user@domain''
part of an e-mail address. Mixminion uses only mailboxes, because the
display name and comment parts of an e-mail address could potentially be
different for senders who have obtained an address from different
sources (leading to smaller anonymity sets). The EMAIL field must be
NUL-terminated.

The TAG field is appended to the message in an X-Remailer-Tag header.

The LOCAL routing type is used for messages to be delivered to a local
user.  The USER field must be NUL-terminated; the TAG field is
free-form.

(Tag fields can be used to implement stateless reply blocks by
reminding recipients of the master secrets they used to generate the
reply block.)

[XXXX Ok, here is my real concern: I do not want every different client
      to implement their own version of the stateless reply block, in
such a way that they cannot interoperate. So I would rather have some 
standard fields containing the HOPS and KEY information along with any
other variable information. -GD]
[XXXX Ok, I agree with your goal of standardizing stateless replies,
      but I think they should go into a section on 'How to do
      stateless replies', so they can be orthogonal to SMTP/LOCAL/Foo  

      Proposed text:
         If a client does not wish to remember all of her outstanding
         reply blocks, she may generate them in 'stateless' mode.  She  
         does so by using an SMTP or LOCAL delivery type, and setting
         the TAG field to 
           (nHops | Encrypt(sha1(password)[0:16]), seed) | padding up to 32b.)

         She uses PRNG(seed, nHops*16) to form the SK's in the reply
[XXXX why *16? What are you trying to do here. -RD]
[XXXX 16 bytes = size of a single secret. -NM]
         block, and to reconstruct them later when she receives the 
         message.
       
         If the client has complete trust in the final hop, she may
         use a null password.  Beware, however: an attacker who recovers 
         the seed can use it to link any of the hops along the reply 
         chain.

	 To keep replies indistinguishable from encrypted/tagged
         forwards, we set the TAG field of SMTP/Local to =exactly=
         32 bytes.

         Sound ok?                                 -NM ]

[XXXX I would add a type field for identification, and I think it is
ok -GD]

[XXXX That's interesting. My first thought would have been to PK-encrypt
      the hop secrets to the recipient. So not even a (separate) password
      needs to be remembered. But I guess that takes up a lot of
      space. -RD]

[XXXX I don't think we need to worry about tampering with the tag:
      it's always in the header, so nobody (IIUC) can tag it fruitfully.

      But if you like what if we had it be:
        TAG= E(sha1(password)[0:16],  (nHops | seed | padding)) ? -NM]

[XXXX I agree with RD comment above.  I thought that the last hop, meant
 to be delivered to the final receipient would be encrypted under his public 
 key. -GD]

[XXXX All right.  What if we have 
         TAG = PK_ENCRYPT(recipient_pk, nHops|seed) ?  
      This requires
      that the recipient have a private key, and thus breaks
      deniability and is not as 'stateless' as the password-only
      approach, but it still works if that's what you want.  -NM]
[XXXX Wait a second: the TAG field is in the, Routing field that is in the 
      subheader. This subheader is already encrypted under the receipients
      public keys, and therefore we do not need to reencrypt it.
      Am I missing something? -GD]
[XXXX For SMTP delivery, the tag is included in an 'X-Remailer-Tag'
      header; see above. -NM]
[XXXX As I had it in my mind there would be two subheaders at the end
         of the message: one with SMTP and one with LOCAL. The SMTP
         tag would make the last machine (other than recipient's) send
         the mail, while the LOCAL (encrypted under the final
         recipient) will still do the decryption and
         decoding. Therefore the X-Remailer-Tag does not contain any
         secrets. The packet encoded to be sent by SMTP is still a
         valid mixminion packet (see email encoding) -GD]
[XXXX What is the advantage of this?  It completely kills deniability
      by requiring recipients to have RSA keys to decrypt the LOCAL
      subheader.  It eats a subheader needlessly.  It adds
      complexity to our system by changing SMTP from a delivery
      mechanism that sends only a (possibly decrypted) payload to a
      full-blown routing message that sends entire packets.  It
      expands the software you need in order to receive replies from
      'decrypt a payload' to full-blown 'decrypt and process a packet'. 

      So what does it get us?  -NM]  
[XXXX I always considered the above described mechanism to be used
only in the case of the last hop (the header before the last valid
one) for SURBs. I did not forsee it as a general SMTP delivery
mechanism. Therefore conceptually the packet transmitted is still the
full mixminion packet, so that the last hop can make sure of its
integrity (using the headers) and can recover secrets in it. I would
argue that only using SMTP in that mode makes it simple (and easier to
include in that document, than having to specify the generic SMTP
delivery mechanism (which must have standard abuse/spam resistance,
volume control, awareness of nyms etc.) -GD]

\subsection{The header structure}

Each type III message has two headers with identical structure. These
headers are swapped at the crossover point.

A header is 16*128 bytes long and contains up to 16
subheaders. Starting with N subheaders SH_0..SH_N containing secrets
SK_0..SK_N (and placing routing extension blocks directly after their
respective subheaders), the header is constructed by appending 
random padding to achieve a total size
of 128*16 bytes. Then, each subheader key is used to create a key
Hash(SharedSecret | ``HEADER SECRET KEY'') with which the part of the
header after the subheader (but including its routing extension) is
encrypted using counter-mode AES.

We construct the subheaders from last to first, so that each can contain
a digest of the subsequent subheaders and padding data.

PROCEDURE: Create a single header.

Inputs: A_1 .. A_N (addresses of intermediate nodes), 
	PK_1 .. PK_N (Public keys of intermediate nodes),
	SK_1 .. SK_N (Secret keys to be shared with intermediate nodes),
        R Routing type and information of last header (FWD, DROP, SWAP, etc.)
Output: H (The header)

Process: 
  // Calculate the sizes of the subheaders
  for i = 1 .. N
	SIZE_i = 128 + Len(EXT(RI_i))

  // Calculate the Junk that will be appended during processing:
  J_0 = ``'';
  for i = 1 .. N
	J_i = J_(i-1) | PRNG(HASH(SK_i, ``RANDOM JUNK'')[0:16], SIZE_i)

        Stream_i = PRNG(HASH(SK_i, ``HEADER SECRET KEY''), 128*16);

	J_i = J_i XOR Stream_i[128*15 -Len(J_i) + SIZE_i:Len(J_i)];
  end

  // Create the Header
  H_(N+1) = Rand(128*16 - sum(SIZE_1 .. SIZE_N));

  for i = N .. 1
	K = HASH(SK_i | ``HEADER SECRET KEY'')[0:16];
	IF i = N (set appropriate routing type and A_i)
	EH = EXT( RI_i )
        REST = Encrypt(K, (EH | H_(i+1)))
  	DIGEST = HASH(REST | J_i)
	H_i = ESHS(PK_i, V, SK_i, DIGEST, F, len(RI_i), RT_i, RI_i) | REST
  end

return H_1;

\subsection{The Payload of messages}

The payload of a Mixminion message has a fixed length of 32 kb
- 2*16*128 bytes = 28kb.   Payloads indicate their size.

  [XXXX Shouldn't size info go into the header, or no place?  Size
     info makes tagged payloads distinguishable from garbage. -NM]
  [XXXX Size info is quite important as well as some type information.
     Maybe in order to minimise the potential for tagging we should
     encrypt the payload using an encryption key specified in the
     reply block. So the reply block would be (SURB, encryption key,
     first hop, deadline). That would make us waste another 128 bytes
     of payload. -GD]
  [Example body encryption: Apply LIONESS on the whole body of the
     message using a predefined key (K = 0x00...00). Encrypt the first
     128 bytes of the payload using an RSA encryption key contained in
     the reply block information. That way the payload looks random
     and only the final receipient can decrypt it (need to include a
     nonce and a digest in the body of the payload as well). BUT we
     have the problem that the key can be changed by the adversary in
     the reply block ... -GD Any comments?]
  [No, I'm afraid I don't know what to do here, or who, exactly is
     transmitting or encrypting what in your proposal.  Keep in mind 
     that generating RSA keys is the single most expensive operation
     in our system.
 
     Wait a minute... are we sure there's a problem at all?  Consider
     what an attacker would see at the last hop =without size info=:
                            REPLY          FORWARD 
          TAGGED MSG     Payload=opaque  Payload=opaque 
          UNTAGGED MSG   Payload=opaque  Payload= Plaintext 

     And =with= size info, so long as it gets LIONESSED with the
     rest of the message...
                            REPLY          FORWARD 
          TAGGED MSG     Payload=opaque  Payload=opaque 
          UNTAGGED MSG   Payload=opaque  Payload=Plaintext with size

     So the problem only seems to arise when you strip the payload
     padding at the server.  But how does the server know not do
     do this with reply payloads anyway?

     I'm just confused here. -NM]
[XXXX See discussion on the mailing list about payload encryption -GD]

Size:   2 bytes
Data:   (Variable)

We denote a payload as P.

\subsection{Constructing messages}

Given two headers and a payload one can construct a
message. The first header must contain a subheader
with routing type SWAP.  

PROCEDURE: Construct a message.

Input: H1 (header containing keys SK1_1... SK1_N)
       and H2 (either a header containing keys SK2_1... SK2_N if
         we constructed it, or a header with unknown keys if we're
         using a reply block.)
       P (Payload)
Output: M (the message)

Process:
	// Phase 1
	if (H2 is *not* a reply block)
		for i = N .. 1
	            P = SPRP_ENC(SK2_i, "PAYLOAD ENCRYPT", P)
		end
        else
	// Phase 2
	H2 = SPRP_ENC(SHA1(P), ``HIDE HEADER'', H2)

	for i = N .. 1
		H2 = SPRP_ENC(SK1_i, "HEADER ENCRYPT",H2)
		P = SPRP_ENC(SK1_i, "PAYLOAD ENCRYPT",P)
	end

\section{Processing of Messages}

Messages are transferred from node to node using either the custom Type
III transport protocol (see below) or email.  A node with private key
PK receiving message M = (H1, H2, P) performs the following operations:

PROCEDURE: Process a message M
	SHS(V, SK, D, RS, RT, RI) = PK_Decrypt(PK,H1[0:128]);
        If there is any problem with the OAEP padding discard the message.
        Check that D = HASH(H1[128:15*128]), and discard if not.
        Let n_extra = number of extended headers = Ceil( (RS-44) / 128 )
                  
        H1 = H1[128:15*128] | PRNG(HASH(SK | "RANDOM 
                                               JUNK")[0:16],128+128*n_extra)
	H1 = H1 XOR PRNG(HASH(SK, "HEADER SECRET KEY")[0:16], Len(H1))
        RI = RI | H[0:128*n_extra]
        H1 = H1[128*n_extra:128*16]
	H2 = SPRP_DEC(SK, ``HEADER ENCRYPT'',H2);
	P = SPRP_DEC(SK, ``PAYLOAD ENCRYPT'',P);

	if routing type is DROP:
                End.
	if routing type is SWAP-FWD:
		H2 = SPRP_DEC(SHA1(P), ``HIDE HEADER'', H2)
		Swap H1 and H2;
        if routing type is SWAP-FWD or FWD:
	   	Put (H1, H2, P) in queue to be sent to the address in RI.
        Otherwise:
		Give (RT, RI, HASH(SK,``APPLICATION KEY''), P) to
		
Module manager. 

\section{Single Use Reply Block exchange formats}

[It should contain, use-by date, first hop address, 
 SURB block, public key, etc.
 We can also have a short hand notation for SURBS that only
 use part of the header. One only needs to specify the 
 blocks containing the SURB and a key to pad the junk -GD]
 [But SURBs should use the whole header, otherwise they're
  leaking length info? -RD]


A SURB can be encoded in a standard binary or ASCII format.

Binary Format:

   Begin Marker: 4 bytes
   Version:      2 bytes
   Use-by-Date:  4 bytes
   SURB header:  2048 bytes
   Routing Size: 2 bytes
   Routing Type: 2 bytes
   Routing Info: (Routing Size) bytes

   Total: 14 bytes + Header size + Routing info size.

* The magic marker contains the ASCII 4-byte string 'SURB'. 
* The version number contains the format version of the SURB.
  (should be hex 01 and 00 for this standard).
* Routing type/routing size/routing info: Definded as in subheaders.  
  These fields encode the address of the hop which the SURB user should
  use as an exit point.
* Use-by-Date: indicated the expiry date the SURB should be used by. Can
  be calculated using the key rotation frequencies of the intermediate
  nodes.  This field must be given as a number of seconds since
  midnight GMT on Jan 1, 1970--but must be aligned to the start of a
  day (in other words, it must be divisible by 60*60*24).
  (Misaligned dates must be rejected as invalid.)

  (Rationale: a seconds-level granularity allows us to move to a
  tighter schedule later on in order to support a synchronous mixnet.)

* SURB data: Containst the SURB that is created as described
  above. 

The ASCII Encoding of SURBs.

The  ASCII compatible format of SURBs is:
-----BEGIN SURB-----
Version: x.x
Base64 encoded binary SURB 
-----END SURB-----

The version number should be in decimal ASCII and is the same as the
binary version.

\section{Email Transport exchange format}

This format should be used when the SMTP address type is used for a
message. The SMTP address is specified in the ``EMAIL ADDRESS'' field,
and the ``TAG'' FIELD should be included in the SMTP header after as
``X-Remailer-Tag'' filed.

The Reply-to field should contain the email address which can be used
to block service to the receipient. The body should also clearly
indicate how the procedure of blocking oneself works.

-----BEGIN ANONYMOUS MESSAGE-----
VERSION: x.x
ID: 48 first bits of the hash of the whole binary message.
Base64 encoded mixminion packet (32kb long -> 44 kb long)
-----END ANONYMOUS MESSAGE-----

The subject line should read: ``Anon. Message: '' + ID

[Need to specify how we are going to wrap the message
 as an email. This is only intended for SURB use and
 we should think more carefully about providing a 
 general SMTP/IMAP service.
 There is a need to provide enough information to be 
 able to block the service, for the recipient to
 filter out messages arriving from the mix network.]

[XXXX This needs more thought.  First, it violates our earlier
      assumptions that routing modules never need to look at the
      headers, but only at their routing info.  Second, it doesn't
      allow people without special software to receive
      sender-anonymous messages.  Third, it requires every message
      recipient to have a full-blown packet processing system when
      they really only need to decrypt the payload.  -NM]

\subsection{Replay Avoidance}

The nodes MUST implement a mechanism to make sure that messages cannot
be replayed. To do this a hash of the secret contained in the
subheader is kept for as long as the public key under which it was
encrypted is in use. The Hash should be computed in the following way:

X = HASH(SharedSecret | ``REPLAY PREVENTION'')

The value X is not secret, and its secrecy should not be relied upon.
The integrity of the list should be secured and the X values lists may
be made public.

\section{Type III (Mixminion) forward secure protocol}

A special channel should be established between mixes that provides
forward secrecy making it impossible to recognize or decrypt any
message that went through it in the past. In order to establish this
channel one of the two mixes initiates the connection but at the end
of the key exchange protocol the channel is bi-directional. The
protocol should be used when the SWAP-FWD/IP4 or FWD/IP4 address type
is specified in a subheader.

The Mixminion protocol uses TLS (the IETF standardization of SSL) with
the ciphersuite "TLS_DHE_RSA_WITH_AES_128_CBC_SHA" (defined in
tls-ciphersuite-03.txt).  No other ciphersuite is permitted for
MIX-to-MIX communications.
[XXXX Do we want to allow other suites for client-to-server
      communication in order to accommodate clients with older SSL
      implementations? -NM]
[XXXX Since we define mixminion now I do not think that we will find
      ``older'' clients out there ;) -GD]
[XXXX OK; my concern was that the most recent released version of
      openssl doesn't support the mentioned ciphersuite.  Nonetheless,
      it seems that NSS and GnuTLS both support it (NSS on the client
      side only), so we needn't worry. -NM]  
[XXXX I think we should choose a suite that is widely supported and
      strong at the same time. -GD]
[XXXX Does that mean we should support something other than
      dhe/rsa/aes128, or not?  Keep in mind that without DHE, you
      don't get forward security. -NM]

X.509 certificates need not be signed; instead, they must contain
a key matching that used in the KEYIDportion of the header's routing
data.  

Messages are sent from client to server; the client must send a
ClientHello packet to renegotiate session key between all
messages. [XXXX why so often? -NM] If the client does not do so, the
server must close the connection.  [XXXX Is this so? -NM]

[XXXX If there is a key updating operation between every message it means
that every message is encrypted under a different key. It also
provides a very small time window for someone breaking down your door
in order to decrypt what you have just transmitted. Is there a problem
with having it so often? -GD]
[XXXX There's no problem, but it seems a little paranoid to me: It's
extra computation, but doesn't really buy us much.  We can get a very
small time window by requiring a new key every 5 minutes, and AES_CBC
can certainly stand up to a lot of packets sent with the same
key. -NM]
[XXXX BTW, DHE handshake is far more expensive than a regular SSL
handshake -- thus, we'd better have SSL sessions to avoid redoing DHE
a lot.  We can maintain forward security by -at a minimum- rekeying
before we suspend a session. -NM]
[XXXX Indeed I was thinking of maintaining sessions, even when the TCP
connection is dropped. Notice that re-keying does not involve any
Public key operations. Doing it every 5 minutes is good enough, or
even doing it when there is not much other traffic. -GD]
[XXXX
 Proposal: When A is done sending a batch of messages, _A_ initiates a
   re-keying operation and then suspends the session.  B allows
   session resumption later on only if 1) less than 120 seconds have
   passed, or 2) A re-keyed immediately before suspending.

   This way, no key that has been used to send messages can be used
   after 120 seconds to send messages again. -NM]
[XXXX
   This is good! -GD]

Protocol outline: (Portions marked with '*' are normative; other
portions are non-normative descriptions of TLS.)

\begin{verbatim}
- A invents a new Diffie Hellman key 
  (of at least 1024 bits modulus)
  and makes a certificate signed by her signing key.
  A then initiates the SSL Handshake protocol with B.
- B invents a DH key and makes a certificate using his signing
  key.
* A checks that the Hash of the signing key is the same as
  the one contained in the routing info of the subheader.
- The SSL handshake protocol proceeds as normal until a session
  key has been established. All communications are then encrypted
  using this session key.

* A sends "PROTOCOL 1.0", CRLF.  This indicates the highest protocol
  version A supports.

  (Future clients that support more protocols should transmit
   "PROTOCOL", a list of comma-separated protocol versions, and a CRLF.)

[Why not having the magic word ``MMTP'' instead of ``PROTOCOL''? -GD]

* If B is not willing to use any protocol A supports, B closes the 
  connection.

  B sends "PROTOCOL 1.0", CRLF.  This indicates B's choice of protocol.

  If A is not willing to support B's choice, A closes the connection.

* A sends "SEND", CRLF, M, HASH(M|"SEND") (6 + 32k + 20 bytes)
* B sends "RECEIVED", CRLF, HASH(M|"RECEIVED") (10 + 20 bytes)

[XXXX Roger was wondering: what is the purpose of the RECEIVED ack? If
   the server goes away without warning, SSL will tell us. -NM]
[XXXX Having a positive reply gives me a warm feeling. me experiance
   with protocol failures tell me that once you have put you message
   in, and the link fails, there is usually difficult to know if the
   last message made it or not. -GD]

[XXXX proposal to allow link-level padding:

  If the hash sent from A to B is incorrect, B instead sends
          "BAD SHA1", CRLF, HASH(M|"BAD SHA1"), (10+20 bytes).

  (We provide this option in order to support link-level padding.  If
  B did not send a hash of the incorrect message, a passive adversary
  could mount a timing against the protocol.  If the "BAD SHA1"
  message were not the same length as the RECEIVED message, an
  adversary might be able to distinguish padding from messages by the
  differing lengths of the reply messages. -NM]
[ I think that we should not allow malformed messages. If you want the
  above then the initial message should be:
	"JUNK", CRLF, M, HASH(M|"JUNK") (6 + 32k + 20 bytes)
  with reply:
	"RECEIVED", CRLF, HASH(M|"RECEIVED JUNK"), (10+20 bytes).
  It looks the same from outside but it does not make the client
  wonder, if the corruption was a bug or not. -GD]


* A sends an TLS handshake renegotiation message.
  (and MUST not reuse the same key for 
   transfering another message)
  This updates the session key and overrides the old ones.
\end{verbatim}

\emph{Note:}

The old keys must be permanently overwritten. Special care should be
taken to permanently erase them from the Hard Disk and memory. 

The standard transport mechanism over which the MixMinion Transfer
Protocol talks is TCP over IP. The standard listening TCP port should be 
number 48099 (until we register a port with www.iana.org)

All possible checks should be performed during the transfer protocol
and if any fail the connection MUST stop and all state MUST
be deleted. An error MAY be logged. In particular, if the address
hash element in the Master Header is nonzero, the certificate of
the communication partners must be signed using a key that hashes
appropriately.

\section{MIX Information Exchange format}

In order to automate and standardize directory servers, we provide 
a standardized extensible server descriptor format.

All server descriptors and statistics blocks follow a simple
section-based key/value format, with items loosely based on RFC822.

-----BEGIN DOCTYPE-----
[Section1]
Key: Value
Key: Value
Key: Value

Key: Value
Key: Value

[Section2]
Key: Value
-----END DOCTYPE-----

[XXXX For configuration files, we should allow a broader format.  It
  should allow '=' and ' ' as synonyms for ':'.  It should also allow
  comments preceded with '#', and line continuations as in RFC 822. -NM]

\subsection{Syntax}

(Notation:  X*: 0 or more occurences of X.
            X+: 1 or more occurences of X.
	    X?: 0 or 1 occurrences of X.
            X Y: An occurrence of X followed by an occurrence of Y.
	    X*{Y}: 0 or more occurrences of X separated by occurences
                  of Y.
            X|Y: Either an occurrence of X, or an occurence of Y.)

Descriptor = CRLF* Beginline Section* Endline CRLF*

Beginline = '-----BEGIN ' Doctype '------' CRLF+

Endline = '-----END ' Doctype '------' CRLF+

Doctype = (<any printable character but '-'>)+

Section = SectionLine EntryLine*

SectionLine = '[' Word ']' CRLF+

.EntryLine = Word ':' ' ' Data CRLF+

Word = (<Any printable, non-space character but ':'>)+

Data = (<any character but CR or LF>)*

CRLF = CR LF

\section{Mixminion descriptor blocks}

This section describes the format of server descriptors, as uploaded
to and downloaded from directory servers.  A server descriptor is a
promise, by a MIX's administrators, to provide a given set of
services, keys, and exit policies over a set period of time.

'Doctype' above must be 'Mixminion Server'.  It must begin with a
'Server' section.  This section includes the entries:

     'Descriptor-Version':  the string "1.0"
     'IP': An IPv4 address, in dotted-quad format.
     'Nickname': A human-readable identifier for this server.  If it
         contains any periods, it must be a fully qualified DNS name
         which resolves to the provided IP for the entire lifetime of
         this Descriptor block.
     'Identity': The modulus of this Mix node's long-term signing key,
         represented in ASN.1, and encoded in BASE64.  Whitespace in
         this field is ignored, to allow the key to span multiple
         lines.  The modulus of this key should be at least 2048 bits
         long.  The exponent of this key must be 65535.

	 Clients should at least give a warning if the identity key of
         any server should ever change. [XXXX Write more in section
         about directory servers. -NM]
     'Signature': The signed digest of this block.  See below.
     'Valid-After': A date, in the form 'DD/MM/YYYY'.  After midnight GMT
         on this date, this server must support the operations listed
         in this descriptor.
     'Valid-Until': A date, in the form 'DD/MM/YYYY'.  Until midnight
         GMT on this date, this server must support the operations listed
         in this descriptor.
     'Contact': An email address that may be used to contact the
         administrator of this server. Optional field.
     'Comments': Human-readable information about this server.  Must
         be <1024 bytes long.  It *must not* be necessary to read this
         information to use the server properly.
     'Packet-Key': The public key used to encode encode subheaders for
         this server, encoded in ASN.1, represented in BASE64. 

[I think we should include a serial number, a unique identifying
number (20 bytes that could be its SHA) the time and date the above
was published. -GD]

The digest of a descriptor block is computed by removing the contents
of the signature field, and computing the SHA-1 digest of
the result.  The signed digest is the OAEP/PCKS1 signature of the
digest with the server's identity key.  This values is
represented in BASE64.

If this server accepts incoming MMTP connections, it MAY have an
'Incoming/MMTP' section, with the following entries:

     'MMTP-Descriptor-Version': The string '1.0'
     'Port': A port at which IP accepts incoming MMTP connections.
     'Key-Digest': The KEYID of this server, encoded in BASE64.
     'Protocols': A comma-separated list of the protocols this
           server accepts.

If this server supports outgoing MMTP connections, it MAY have a
'Modules/MMTP' section, with one entry each of the form:

      'MMTP-Descriptor-Version': The string '1.0'
      'Protocols': A comma-separated list of the protocols this server
           supports for outgoing connections.

and any number of entries of the form:

      'Allow': Address
      'Deny': Address

The Address tokens are of the form:

   Address = IP ('/' Mask)? (Port ('-' MaxPort)?)?

An omitted mask defaults to 255.255.255.255.  An omitted portrange
defaults to 48099 on ALLOW and 0-65535 on DENY.

The entries are order-significant; the first one to match wins.

The default policy is 'Deny: 0.0.0.0/0.0.0.0'

If this server supports outgoing SMTP connections, XXXX

If this server supports LOCAL delivery, XXXX

Other services provided by this server should each have their own section.

(Note: A server need not advertise all of its capabilities; it is
permissible (for example) for a server that supports incoming MMTP
connections to omit the Incoming/MMTP section.)

A client should ignore any sections it does not recognize, but should
not use any service whose sections have an unrecognized descriptor
version.

\subsection{Directories and Directory servers}

A directory is a list of Mixminion servers which are believed to
be operational at a given time.

A directory server provides an HTTP URL for uploading server
descriptors, an HTTP URL for downloading a directory, and a long-term
public key (2048 bits).

To upload a descriptor block, a client performs an HTTP POST request
to the upload URL, with the server block as enclosed entity.

To retrieve the directory, a client performs an HTTP GET request on
the directory URL.

[XXXX There should be a way to request a diff of entries since a given
time, rather than the entire directory. -NM]

A directory takes the following form:

-----BEGIN Mixminion Directory-----
Version: 1.0
Identity: <Base64-encoded public key, in ASN.1>
Signature: <Base64-encoded OAEP/PCKS1 signature of this document, with
     the contents of this field removed.>
-----BEGIN Mixminion Server-----
 ....
-----END Mixminion Server-----
-----BEGIN Mixminion Server-----
 ....
-----END Mixminion Server-----
-----END Mixminion Directory-----

[XXXX The nesting is getting a little nasty here.  This may be our
   last chance to use XML.  I'm leaning this way now, but I'd
   really like any ideas pro or con. -NM]

Directory servers change their directories only at midnight GMT.  Any
client which has not downloaded a directory since before midnight GMT,
must download a fresh directory before generating any packets.

[There is going to be an orgy of traffic analysis exploits there. I
think we should be less strict about having to download the directory
before sending. And maybe allow anonymous access to direcoty
servers. (Hey the first application!) -GD]

A directory includes all the servers that were uploaded to the
directory before some cutoff time the previous day, and which proved
upon some random number of tests and probings to have a real Mixminion
server running on them.  A directory server periodically re-tests
the servers in its directory to make sure they have not gone down.

Because of possible attacks related to accidentally or maliciously
unsynchronized servers, we leave the presence of multiple directory
servers for a later draft.

[XXXX We need to support multiple directory servers. I propose we
   leave this for later. -NM]
[XXXX I think we should by default support multiple servers, otherwise
   we have a weak link in the chain. The operator of the Directory can
   screw everybody. -GD]

\section{Statistics Information Exchange formats}

[Stats, reputation, ... Roger?]

Receiving a reply?

Sending SMTP

Local delivery

